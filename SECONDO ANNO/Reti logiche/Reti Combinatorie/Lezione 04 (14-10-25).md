## Sintesi di reti in forma SP a costo minimo

Esistono due criteri di costo: 
- **a porte**: ogni porta conta per un'unita di costo.
- **a diodi**: ogni ingresso conta per un'unità di costo.

>[!NOTE]
>Costo(AND a 10 ingressi) = Costo(AND a 2 ingressi) con il criterio a porte
Costo(AND a 10 ingressi)=5 Costo(AND a 2 ingressi) con il secondo

Questo è un metodo che si applica quando ci sono reti a più uscite e produce reti in forma SP a 2 livelli di logica
- tra tutte queste viene trovato quello a costo minimo.
![[SistesiRetiInFormaSPCostoMinimo.png]]

---
## Espansione di Shannon

L’**espansione di Shannon** (o _teorema di espansione di Shannon_) è un metodo per **scomporre una funzione booleana** in funzioni più semplici, fissando il valore di una variabile alla volta (0 o 1).

È una **tecnica fondamentale** in analisi e sintesi di reti logiche combinatorie, utile per progettare circuiti ottimizzati o realizzare funzioni tramite multiplexers o decoder.

### Formula generale

Data una funzione booleana $F(x_1, x_2, \dots, x_n)$, l’espansione di Shannon rispetto alla variabile $x_i$ è:

$$
F = x_i \cdot F_{x_i=1} + \overline{x_i} \cdot F_{x_i=0}
$$
dove:
- $F_{x_i=1}$​: funzione ottenuta **ponendo $x_i = 1$** in FFF
- $F_{x_i=0}$​: funzione ottenuta **ponendo $x_i = 0$** in FFF
Il simbolo “+” rappresenta l’**OR**, mentre “·” è l’**AND**.

### Significato logico

- $\overline{x_i} \cdot F_{x_i=0}$ → attiva la parte della funzione valida quando $x_i = 0$
- $x_i \cdot F_{x_i=1}$​ → attiva la parte valida quando $x_i = 1$
- La somma (OR) delle due copre tutti i casi possibili della variabile $x_i$​

---
## Forma canonica SP:

La **forma canonica SP (Somma di Prodotti)** è una **rappresentazione standard di una funzione booleana** come **OR di termini AND**, dove ogni termine (prodotto) rappresenta **una combinazione di variabili che rende la funzione vera**.

È anche detta **forma canonica disgiuntiva** o **forma canonica delle mintermini**.

---
## Metodo di Quine–McCluskey

Il **metodo di Quine–McCluskey** serve per **semplificare funzioni booleane** espresse in forma **SP canonica** (Somma di Prodotti), in modo **algoritmico e sistematico** — è il metodo “manuale” alla base dei software di sintesi logica (come il metodo delle **mappe di Karnaugh**, ma più generale).

Si parte dalla funzione booleana espressa come:

$$
F = \sum m(i_1, i_2, i_3, \dots)
$$

dove ogni $m(i)$ è un **mintermine** (cioè una combinazione di variabili per cui $F = 1$).
- Modo piu' efficiente di cercare fusioni tra mintermini/implicanti 
- Basta ordinarli per numero crescente di 1 (var. dirette) 
	- Fusione possibile solo tra partizioni adiacenti 
	- Numero di confronti ridotto
- Efficienza dell'algoritmo dipende dalla facilita' di trovare stati di ingresso adiacenti riconosciuti dalla legge
![[SemplificoFormaCanonicaSP.png]]

>[!NOTE] Cos'è un implicante
>L'implicante è il prodotto di alcune variabili di ingresso dirette o negate che riconosce alcuni stati di ingresso

>[!NOTE] Cos'è un mintermine
>Un mintermine è un caso particolare di implicante

Quello che bisogna fare quindi è:
- Applicare esaustivamente la legge $\alpha x \space + \space \alpha = \alpha$ 
- Togliere tutti gli implicanti che hanno prodotto qualcosa per fusione
- Si ottiene la lista degli implicanti principali
$$
z = \overline{x_3} \space \cdot \space x_1 \space + \space \overline{x_3} \space \cdot \space \overline{x_2} \space \cdot x_0 \space + \space \overline{x_2} \space \cdot \space x_1 \space \cdot \space \overline{x_0} \space + \space x_3 \cdot \overline{x_2} \cdot \overline{x_1}
+ x_3 \cdot \overline{x_2} \cdot \overline{x_0}
$$

---
## Lista di copertura (non) ridondante

**_Lista di copertura_**: lista di implicanti, la cui somma una forma SP per la funzione $f$. 
- lista dei mintermini 
- lista degli implicanti (cioé quella ottenuta prima della semplificazione) 
- lista degli implicanti
**_Lista di copertura non ridondante_**: se tolgo un elemento smette di essere una lista di copertura. 
**_La lista dei mintermini_** é una lista **non ridondante**.
- Infatti, se ne tolgo uno, uno stato di ingresso riconosciuto non sarà coperto (quindi non avrò più una lista di copertura) 
La lista degli **implicanti principali** essere ridondante.

---
## Mappe di Karnaugh

- Per una rete ad $N$ ingressi è una matrice di 2<sup>N</sup> celle
- Celle **contingue** sulla mappa hanno coordinate adiacenti (e viceversa).
- Oltre le 4 coordinate serve la 3a dimensione (per rimanere continue alla proprietà dell'adiacenza delle coordinate).
![[MappaDiKarnaughEsempio.png]]
### Sottocubi di ordine 1

- Sottocubo di ordine 1
	- Casella che contiene un 1, corrispondente quindi ad uno stato di ingresso riconosciuto dalla rete 
- Coordinate di un sottocubo di ordine 1 
	- stato di ingresso corrispondente al sottocubo 
- Adiacenza tra sottocubi di ordine 1 
	- due SO1 sono adiacenti se differiscono tra loro per una sola coordinata
### Sottocubi di ordine 2

- Sottocubo di ordine 2 
	- costituito da sottocubi adiacenti di ordine 1. 
	- C'è un S02. 
	- Le sue coordinate sono: $x_2 = - \space x_1 = 1 \space |\space x_0 = 1$ 
- Il SO2 C copre i SO1 A e B
- Adiacenza tra i sottocubi di ordine 2
	- due SO2 sono adiacenti se differiscono tra loro per una sola coordinata.

---
## Sottocubi e implicanti

- Sottocubi e implicanti sono più o meno la stessa cosa perché entrambi si riferiscono a raggruppamenti di celle in una mappa di Karnaugh che semplificano una funzione booleana, ma mentre gli implicanti sono i gruppi che formano i termini principali dell'espressione, i sottocubi sono una sorta di 'sottoinsieme' di queste aree che possono essere utilizzati per identificare le semplificazioni più precise.

---
## Algoritmo per la ricerca dei S. principali

- Parto dai sottocubi di ordine più grande che trovo sulla mappa
	1. Considero i sottocubi di ordine p _non interamente contenuti in sottocubi di ordine più grande_
		- Li segno tutti
		- Non essendo contenuti in sottocubi di ordine maggiore sono senz'altro principali.
	2. **_Domanda_**: l'insieme dei sottocubi che ho trovato finora basta a coprire tutta la mappa?
		- Se si, ho finito
		- Se no, $p \leftarrow p/2$ e ripeto il ciclo
- L'algoritmo poi termina di sicuro (_al più quando $p = 1$)

![[EsempioSottoCubiAlgoritmo1.png]]
![[EsempioSottoCubiAlgoritmo2.png]]

---
## Ricerca delle liste di copertura non ridondanti

I sottocubi principali vanno **classificati** e alcuni sono **gli unici a coprire un dato sottocubo di ordine 1**. 
- non possono essere tolti, se vogliamo coprire tutti gli stati riconosciuti dalla rete.
- Sono detti **essenziali** e costutiscono il **cuore della mappa**.

>[!IMPORTANT] Come trovarli?
>Basta guardare se ci sono degli 1 cerchiati una sola volta
>
>![[ListeCoperturaNonRidondanti.png]]

---
## Sottocubi essenziali e assolutamente eliminabili

Si spuntano tutti i sottocubi di ordine 1 contenuti in sottocubi principali **essenziali** e si copre completamente **anche** qualche altro sottocubo
- quel sottcubo è ridondante
- assolutamente eliminabile, non deve comparire in una lista di copertura irridondante.
Un sottocubo principale è **assolutamente eliminabile** se riconosce **soltanto** stati di ingresso già riconosciuti da sottocubi principali **essenziali**.

---
## Lista di copertura di costo minimo

- Generare **tutte le possibili liste di copertura _non ridondanti_** che:
	- includono tutti i sottocubi principali essenziali
	- non includono NESSUN sottocubo principale assolutamente eliminabile
	- includono un sottoinsieme di sottocubi principali semplicemente eliminabili
- Tra tutte queste, valuto quella di costo minimo applicando il criterio di costo richiesto.
- Considero un qualunque sottocubo S.E.
	- Formulo due ipotesi alternative
		a) Come se fosse **essenziale**, lo aggiungo alla lista di copertura e qualche altro sottocubo diventa assolutamente eliminabile.
		b) Come se fosse **assolutamente eliminabile**, lo tolgo da qualche lista di copertura e qualche altro sottocubo diventa essenziale

---
