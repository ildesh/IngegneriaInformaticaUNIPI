### Reti combinatorie a due ingressi

Ad alcune corrispondono nomi speciali:

| x₁ | x₀ | z⁽⁰⁾ | z⁽¹⁾ | z⁽²⁾ | z⁽³⁾ | z⁽⁴⁾ | z⁽⁵⁾ | z⁽⁶⁾ | z⁽⁷⁾ | z⁽⁸⁾ | z⁽⁹⁾ | z⁽¹⁰⁾ | z⁽¹¹⁾ | z⁽¹²⁾ | z⁽¹³⁾ | z⁽¹⁴⁾ | z⁽¹⁵⁾ |
|:--:|:--:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:------:|:------:|:------:|:------:|:------:|:------:|
| 0  | 0  | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 0  | 1  | 0 | 1 | 0 | 1 | 0 | 1 | 1 | 0 | 0 | 1 | 0 | 1 | 1 | 1 | 1 | 1 |
| 1  | 0  | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 0 | 1 | 1 | 1 | 1 | 1 |
| 1  | 1  | 1 | 0 | 1 | 0 | 1 | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 |

![[TabelleDiVerità_DUEINGRESSI.png]]

a) **_porta AND_**: `z = x₀ ∧ x₁ → 1` solo se entrambi gli ingressi sono 1
	- _(È una **moltiplicazione logica**: 1×1=1, tutto il resto 0)_.
b) **_porta XOR_**: `z = x₀ ⊕ x₁ → 1` vale 1 quindi se gli ingressi sono diversi.
	- _È una **somma mod 2**._ 
c) **_porta OR_**: `z = x₀ ∨ x₁ → 1` se almeno uno degli ingressi è 1.
	- _È una **somma logica**._
d) **_porta NOR_**: `z = ¬(x₀ ∨ x₁) → 1` solo se entrambi gli ingressi sono 0.
	- _L’uscita è `1` **solo se entrambi gli ingressi sono 0**._
e) **_porta XNOR_**: `z = ¬(x₀ ⊕ x₁) → 1` vale 1 quindi se gli ingressi sono uguali.
	- _L’uscita è `1` **solo se gli ingressi sono uguali**._
f) **_porta NAND_**: `z = ¬(x₀ ∧ x₁) → 0` solo se entrambi gli ingressi sono 1.
	- _L’uscita è `0` **solo se entrambi gli ingressi sono 1**._
#### AND e OR a più ingressi
Posso pensare di estendere la funzione logica realizzata dalle porte AND e OR al caso di N ingressi.

- AND ad N ingressi: l'uscita vale 1 se e solo se tutti gli ingressi valgono 1
- OR ad N ingressi: l'uscita vale 1 se e solo se almeno un ingresso vale 1

**Ritardo logico**: più livelli di porte → maggiore il ritardo totale.
**Fan-in massimo**: ogni porta ha un numero massimo di ingressi supportati (tipico nelle implementazioni reali).
#### AND a 2<sup>N</sup> ingressi
Disporre le porte ad albero binario bilanciato 
Numero di LL attraversati è minimo 
>[!TIP] Stessa cosa vale per le OR
#### AND e OR con tanti ingressi
>[!NOTE] Spiegazione Visiva e teorica
>![[RappresentazioneGraficaAND_OR_tanti_ingressi.png]]
>
> ### AND con tanti ingressi
>- Ogni **linea verticale** rappresenta un **filo** di ingresso (X₇, X₁, X₀, ecc.)
>- Il **pallino nero (•)** indica il **punto di connessione** tra il filo e la porta
>- Tutti questi fili entrano nella porta AND
>- I "..." indicano che ci sono altri ingressi in mezzo (X₆, X₅, X₄, X₃, X₂)
>
> ### OR con tanti ingressi
> **Stessa logica:**
>- Fili verticali = ingressi
>- Pallini = punti di connessione
>- Tutti entrano nella porta OR
>
>Immagina un **circuito elettrico reale**:
>1. **Le linee verticali** = cavi elettrici che portano i segnali
>2. **I pallini neri** = punti dove i cavi si "saldano" alla porta logica
>3. **La porta (AND/OR)** = chip elettronico che elabora i segnali
>4. **L'uscita** = il risultato che esce dal chip
>
>INGRESSI              PORTA           USCITA
>       ↓                    ↓               ↓
 >       
   X₇ ──•──┐
   X₆ ──•──┤
   X₅ ──•──┤
   X₄ ──•──┤              
   X₃ ──•──┤─── AND ────────→ Y
   X₂ ──•──┤
   X₁ ──•──┤
   X₀ ──•──┘
>Ogni pallino (•) = "questo filo entra nella porta"

---
## Algebra di Boole
Formalismo per rappresentare le leggi di corrispondenza delle reti combinatorie 
Sistema algebrico basato su: 
- variabili logiche, capaci di assumere due valori (0 e 1) 
- operatori logici: si applicano alle variabili logiche per costruire espressioni algebriche
### Operatori logici
- Complemento: Operatore unario. Si indica con: $\bar{x}$ ( _anche: **!x** oppure **/x**_ ). E' definito come:
$$ \bar{0} = 1 \text{, } \bar{1} = 0 \text{.} $$
- Prodotto logico: x • y, definito come:
$$
\begin{array}{cc|c} A & B & A \cdot B \\ \hline 0 & 0 & 0 \\ 0 & 1 & 0 \\ 1 & 0 & 0 \\ 1 & 1 & 1 \\ \end{array}
$$
- Somma logica: x + y, definita come:
$$
\begin{array}{cc|c} A & B & A + B \\ \hline 0 & 0 & 0 \\ 0 & 1 & 1 \\ 1 & 0 & 1 \\ 1 & 1 & 1 \\ \end{array}
$$
>[!TIP] #### Proprietà degli operatori booleani:
>![[ProprietàOperatoriBooleani.png]]

---
### Teoremi di De Morgan per N variabili logiche

- I teoremi di De Morgan valgono per un numero qualunque di variabili logiche.
$$ 1.\space \space \overline{x_0 \space \cdot x_1 \space \cdot \space ... \space \cdot x_{N-1} } = \overline{x_0}\space + \space \overline{x_1} \space + \space ... \space + \space \overline{x_{N-1}} $$
$$ 2.\space \space \overline{x_0 \space + x_1 \space + \space ... \space + x_{N-1} } = \overline{x_0}\space \cdot \space \overline{x_1} \space \cdot \space ... \space \cdot \space \overline{x_{N-1}} $$
- Si dimostrano **per induzione** sul numero di variabili logiche:
	- dimostrare che la proprietà vale per un certo numero n<sub>0</sub> (_passo base_)
	- dimostrare che, se vale per un generico n $\geq$  n<sub>0</sub> , allora vale anche per n + 1 (_passo induttivo_).
#### Dimostrazione della prima tesi

---
### Algebra di Boole e reti combinatorie

- **data una rete combinatoria** è sempre possibile trovare un'espressione booleana che mette in relazione ogni sua uscita con gli ingressi.
- **data un'espressione booleana**, è sempre possibile sintetizzare una rete combinatoria (ad un'uscita) in cui la relazione tra ingresso ed uscita è data dall'espressione.

>[!NOTE] Espressioni logiche equivalenti $\leftrightarrow$ reti logiche che svolgono lo stesso compito

- Non necessariamente **con lo stesso conto**
	- Le porte logiche dissipano energia, costano, si rompono e provocano ritardo
	- Meno ne mettiamo, meglio è
- Dobbiamo trovare il modo per **minimizzare il costo della sintesi** di una data legge di corrispondenza.
# Algebra di Boole e reti combinatorie

## Concetti Fondamentali

- **Data una rete combinatoria** è sempre possibile trovare un'espressione booleana che mette in relazione ogni sua uscita con gli ingressi.
- **Data un'espressione booleana**, è sempre possibile sintetizzare una rete combinatoria (ad un'uscita) in cui la relazione tra ingresso ed uscita è data dall'espressione.

> [!NOTE] Espressioni logiche equivalenti ↔ reti logiche che svolgono lo stesso compito
> ![[AlgebraDiBoole+RetiCombinatorie.png]]

- Non necessariamente **con lo stesso costo**
    - Le porte logiche dissipano energia, costano, si rompono e provocano ritardo
    - Meno ne mettiamo, meglio è
- Dobbiamo trovare il modo per **minimizzare il costo della sintesi** di una data legge di corrispondenza.

---

> [!TIP] #### Esercizio 1: Dimostrare l'identità Dimostrare che la seguente identità è vera: $$ x_1 \cdot x_2 + x_2 \cdot x_3 + \bar{x_1} \cdot x_3 = x_1 \cdot x_2 + \bar{x_1} \cdot x_3 $$
>
>### Metodo 1: Tabella di Verità
>
>Costruiamo la tabella per entrambi i lati dell'equazione:
>
>
| $x_1$ | $x_2$ | $x_3$ | $x_1 \cdot x_2$ | $x_2 \cdot x_3$ | $\bar{x_1} \cdot x_3$ | **SINISTRA** | **DESTRA** |
| ----- | ----- | ----- | --------------- | --------------- | --------------------- | ------------ | ---------- |
| 0     | 0     | 0     | 0               | 0               | 0                     | **0**        | **0**      |
| 0     | 0     | 1     | 0               | 0               | 1                     | **1**        | **1**      |
| 0     | 1     | 0     | 0               | 0               | 0                     | **0**        | **0**      |
| 0     | 1     | 1     | 0               | 1               | 1                     | **1**        | **1**      |
| 1     | 0     | 0     | 0               | 0               | 0                     | **0**        | **0**      |
| 1     | 0     | 1     | 0               | 0               | 0                     | **0**        | **0**      |
| 1     | 1     | 0     | 1               | 0               | 0                     | **1**        | **1**      |
| 1     | 1     | 1     | 1               | 1               | 0                     | **1**        | **1**      |
>
>**Dove:**
>- **SINISTRA** = $x_1 \cdot x_2 + x_2 \cdot x_3 + \bar{x_1} \cdot x_3$
>- **DESTRA** = $x_1 \cdot x_2 + \bar{x_1} \cdot x_3$
>
 >**Le due colonne sono identiche** → L'identità è vera!
>
><div style="margin-top: 10px; margin-bottom: 10px; border: 1px solid gray"></div>
>
> ### Metodo 2: Dimostrazione Algebrica
>
>Partiamo dal lato sinistro e dimostriamo che è uguale al destro:
>$$ \begin{align} &x_1 \cdot x_2 + x_2 \cdot x_3 + \bar{x_1} \cdot x_3 \ &= x_1 \cdot x_2 + x_2 \cdot x_3 \cdot (x_1 + \bar{x_1}) + \bar{x_1} \cdot x_3 \quad \text{(perché } x_1 + \bar{x_1} = 1\text{)} \ &= x_1 \cdot x_2 + x_2 \cdot x_3 \cdot x_1 + x_2 \cdot x_3 \cdot \bar{x_1} + \bar{x_1} \cdot x_3 \quad \text{(distributiva)} \ &= x_1 \cdot x_2 + x_1 \cdot x_2 \cdot x_3 + x_2 \cdot x_3 \cdot \bar{x_1} + \bar{x_1} \cdot x_3 \quad \text{(commutatività)} \ &= x_1 \cdot x_2 \cdot (1 + x_3) + \bar{x_1} \cdot x_3 \cdot (x_2 + 1) \quad \text{(raccoglimento)} \ &= x_1 \cdot x_2 \cdot 1 + \bar{x_1} \cdot x_3 \cdot 1 \quad \text{(perché } 1 + x = 1\text{)} \ &= x_1 \cdot x_2 + \bar{x_1} \cdot x_3 \end{align} $$

---
>[!TIP] #### Esercizio 2: Semplificazione di un'espressione booleana. **Obiettivo:** Utilizzando le proprietà dell'algebra di Boole, semplificare l’espressione seguente: $$ F = \overline{a} \cdot \overline{b} \cdot \overline{c} \cdot \overline{d} + \overline{a} \cdot b \cdot \overline{c} \cdot \overline{d} + a \cdot \overline{b} \cdot \overline{c} \cdot \overline{d} + \overline{a} \cdot b \cdot d + b \cdot c \cdot d + a \cdot b \cdot d $$
>- **Raggruppiamo i termini simili:**  
>  I primi tre termini contengono tutti $\overline{c} \cdot \overline{d}$:
>  $$
>  F = \overline{c} \cdot \overline{d} \, (\overline{a}\overline{b} + \overline{a}b + a\overline{b}) 
>  + (\overline{a}bd + bcd + abd)
>  $$
>
>- **Semplifichiamo il fattore** $\overline{a}\overline{b} + \overline{a}b + a\overline{b}$:  
>  $$
>  \overline{a}\overline{b} + \overline{a}b = \overline{a}(\overline{b}+b) = \overline{a} \cdot 1 = \overline{a}
>  $$
>  Aggiungendo $a\overline{b}$:
>  $$
>  \overline{a} + a\overline{b} = \overline{a} + \overline{b} \quad (\text{proprietà: } X + \overline{X}Y = X + Y)
>  $$
> |X|Y|X̄|X̄·Y|X + X̄·Y|
|---|---|---|---|---|
|0|0|1|0|0 + 0 = 0|
|0|1|1|1|0 + 1 = 1|
|1|0|0|0|1 + 0 = 1|
|1|1|0|0|1 + 0 = 1|
>
>   → Risultato = X + Y
>
>  Quindi i primi tre termini diventano:
>  $$
>  \overline{c} \cdot \overline{d} \, (\overline{a} + \overline{b})
>  $$
>
>- **Raggruppiamo i termini con $d$:**  
>  I termini rimanenti sono:
>  $$
>  \overline{a}bd + bcd + abd
>  $$
>  Combiniamo $\overline{a}bd + abd$:
>  $$
>  (\overline{a}+a)bd = bd
>  $$
>  Aggiungendo $bcd$:
>  $$
>  bd + bcd = bd(1+c) = bd
>  $$
>
>- **Combiniamo i due blocchi:**  
>  $$
>  F = \overline{c} \cdot \overline{d} \, (\overline{a} + \overline{b}) + bd
>  $$
>
>- **Espressione finale:**  
>  $$
>  \boxed{F = (\overline{a} + \overline{b}) \cdot \overline{c} \cdot \overline{d} + b \cdot d}
>  $$

---
## Decoder

Il decoder è una rete con N ingressi e p uscite, con p = 2<sup>N</sup>. La sua legge di corrispondenza è la seguente:
$$ \begin{align} &\text{Ogni uscita riconosce uno ed un solo stato in ingresso,} \\ &\text{in particolare \textbf{l'uscita j-esima riconosce lo stato di ingresso}} \\ &\text{\textbf{i cui bit sono la codifica di j in base 2}} \space \text{cioè se: } \\&(x_{N-1}x_{N-2}...x_1x_0)_{b2} \equiv j'' \end{align} $$
### Decoder N to 2<sup>N</sup>

Questa è la **definizione generale** del decoder:
- **N ingressi** → possono assumere 2<sup>N</sup> combinazioni diverse
- **2<sup>N</sup> uscite** → una per ogni possibile combinazione in ingresso
- **Funzionamento**: Solo UNA uscita alla volta è attiva (= 1), tutte le altre sono a 0

$$ y_j = \begin{cases} 1 \space \space \text{se } (x_{N-1}...x_1x_0)_{b2} = j \\ & \text{dove j va da 0 a } 2^N - 1 \\ 0 \space \space \text{altrimenti} \end{cases}$$

In pratica, il decoder “accende” l’uscita con l’indice uguale al numero binario dato dagli ingressi.

---
#### Esempio e Sintesi del Decoder 1 to 2:

- 1 ingresso (`x₀`)
- 2 uscite (`y₀`, `y₁`)

|x₀|y₁|y₀|
|---|---|---|
|0|0|1|
|1|1|0|
Se l’ingresso è `0`, si attiva **y₀**.  Se l’ingresso è `1`, si attiva **y₁**.

Ogni uscita è una combinazione logica degli ingressi:

|Uscita|Espressione|
|---|---|
|y₀|¬x₀|
|y₁|x₀|

---
#### Esempio del Decoder 2 to 4

- 2 ingressi (`x₁`, `x₀`)
- 4 uscite (`y₀`, `y₁`, `y₂`, `y₃`)

|x₁|x₀|y₃|y₂|y₁|y₀|
|---|---|---|---|---|---|
|0|0|0|0|0|1|
|0|1|0|0|1|0|
|1|0|0|1|0|0|
|1|1|1|0|0|0|

Significa che:
- se (x₁x₀) = 00 → y₀ = 1
- se (x₁x₀) = 01 → y₁ = 1
- se (x₁x₀) = 10 → y₂ = 1
- se (x₁x₀) = 11 → y₃ = 1

---
## Decoder con enabler (_espandibile_)

>[!WARNING] Attenzione...
>Il **decoder base** (senza enabler) **non è espandibile**:
>
>- Non è possibile costruire un decoder più grande combinando decoder più piccoli.
  >  
>- Non c’è modo di “accendere” o “spegnere” selettivamente un decoder. 
>
>Per risolvere questo limite, si aggiunge un **ingresso di abilitazione** (detto anche **enabler** o **enable input**).

Un **decoder con enabler** è un normale decoder che funziona **solo quando l’ingresso di abilitazione è attivo**. Il **vantaggio dell’enabler** è che permette di **collegare più decoder insieme per costruire decoders di dimensioni maggiori, senza dover duplicare inutilmente porte logiche**.

>[!CAUTION] Se l’enabler è disattivo, **tutte le uscite sono 0**, indipendentemente dagli ingressi.

---
### Sintesi del decoder con **enabler**

Aggiungere due porte AND in sequenza è inefficiente, quindi è più pratico **introdurre un ingresso di abilitazione (enabler)**.
Per definizione, l’AND è **associativo**, cioè:
$$(a \cdot b) \cdot c = a \cdot (b \cdot c)$$
Questo permette di trattare l’enabler come un **fattore aggiuntivo** nello stesso AND, evitando porte inutili.
- Quando **l’enabler è a 1**, il decoder funziona normalmente;
- Se **l’enabler è a 0**, **tutte le uscite sono forzate a 0**.  
In altre parole, l’enabler permette di “accendere” o “spegnere” l’intero decoder senza modificare la logica interna.

---
#### Costruzione di decoder 4to16 da decoder 2to4

Poiché **2-to-4 decoder** genera 4 uscite, per ottenere 16 uscite dobbiamo **usare 4 decoder da 2-to-4** per le uscite finali. Ma dobbiamo anche decidere quale decoder secondario attivare in base ai **bit più significativi** x₃ e x₂. **L'Idea chiave** è la seguente:
- I **due bit più significativi** (x₃, x₂) selezionano quale dei quattro decoder secondari sarà attivo.
- I **due bit meno significativi** (x₁, x₀) vengono dati **in parallelo a tutti e quattro i decoder secondari**.
- Le uscite del decoder principale (che legge x₃x₂) vengono usate per **abilitare uno dei quattro decoder secondari**.
##### **1.1 Step by step**

1. **Decoder principale (top-level):**
    - È un decoder 2-to-4 che prende come ingressi x₃ e x₂.    
    - Le sue 4 uscite (chiamiamole E₀, E₁, E₂, E₃) servono come **enable** per i quattro decoder secondari.
2. **Decoder secondari:**
    - Sono quattro decoder 2-to-4 identici, ognuno con ingressi x₁ e x₀.
    - Ogni decoder secondario è abilitato da una sola uscita del decoder principale.
3. **Connessione uscite:**
    - Ogni decoder secondario genera 4 uscite.
    - Poiché ci sono 4 decoder secondari × 4 uscite ciascuno = 16 uscite totali.
    - Ogni uscita del decoder secondario corrisponde a una combinazione unica dei 4 bit x₃x₂x₁x₀.
##### 1.2 Schema concettuale

```pgsql
          x3 x2
           │
           ▼
     ┌─────────────┐
     │ 2-to-4      │
     │ decoder     │
     │ (enable)    │
     └─────────────┘
       │  │  │  │
       E0 E1 E2 E3
       │  │  │  │
   ┌───┘  │  │  └───┐
   ▼      ▼  ▼      ▼
2-to-4  2-to-4 2-to-4 2-to-4
x1x0    x1x0  x1x0   x1x0
││││    ││││  ││││   ││││
Y0..Y3  Y4..Y7 Y8..Y11 Y12..Y15

```

**Spiegazione dello schema:**
- Quando x₃x₂ = 00 → E0=1, E1=E2=E3=0 → solo il primo decoder secondario è attivo → Y0..Y3 possono cambiare in base a x₁x₀.
- Quando x₃x₂ = 01 → E1=1, E0=E2=E3=0 → solo il secondo decoder secondario è attivo → Y4..Y7 cambiano in base a x₁x₀.
- E così via fino a x₃x₂=11.
##### ## **1.3 Vantaggi di questo metodo**

1. **Modularità**: possiamo costruire decoders più grandi usando decoders più piccoli già pronti.
2. **Riduzione complessità logica**: invece di scrivere direttamente 16 equazioni logiche per Y0..Y15, si usano blocchi riutilizzabili.
3. **Scalabilità**: stesso principio per 8-to-256 decoder usando 4-to-16 decoder come base.
##### 1.4 Dettaglio attraverso le tabelle di verità

| x3  | x2  | x1  | x0  | Uscita attiva |
| --- | --- | --- | --- | ------------- |
| 0   | 0   | 0   | 0   | Y0            |
| 0   | 0   | 0   | 1   | Y1            |
| 0   | 0   | 1   | 0   | Y2            |
| 0   | 0   | 1   | 1   | Y3            |
| 0   | 1   | 0   | 0   | Y4            |
| 0   | 1   | 0   | 1   | Y5            |
| ... | ... | ... | ... | ...           |
| 1   | 1   | 1   | 1   | Y15           |
Si vede chiaramente che x₃x₂ determina quale “blocco da 4 uscite” è attivo, mentre x₁x₀ determina quale uscita all’interno del blocco si attiva.

---
## Demultiplexer

Il **_Demultiplexer_** è una rete con N + 1 ingressi e p = 2<sup>N</sup> uscite
- x si chiama **variabile da commutare**
- gli altri si chiamano **variabili di comando** che individua una delle uscite
La j-sima uscita insegue la variabile da commutare se e solo se:
$$ z_j =
\begin{cases}
	x \space \space(b_{N-1}b_{N-2}...b_1b_0)_2 \equiv j \\ \\
	0 \space \space altrimenti
\end{cases}
$$
Nella forma booleana esplicita:
$$
\begin{cases}
	z_0 = x \cdot \overline{b_{N-1}} \cdot \overline{b_{N-2}} \cdot \ldots \cdot \overline{b_1} \cdot \overline{b_0} \\[6pt]
	z_1 = x \cdot \overline{b_{N-1}} \cdot \overline{b_{N-2}} \cdot \ldots \cdot \overline{b_1} \cdot b_0 \\[6pt]
	z_2 = x \cdot \overline{b_{N-1}} \cdot \overline{b_{N-2}} \cdot \ldots \cdot b_1 \cdot \overline{b_0} \\[6pt]
	\vdots \\[6pt]
	z_{2^N - 1} = x \cdot b_{N-1} \cdot b_{N-2} \cdot \ldots \cdot b_1 \cdot b_0
\end{cases}
$$
Dove:
- x è **l’ingresso dati**;
- b<sub>N−1</sub>...b<sub>N-1</sub>​ sono i **bit di selezione**;
- ogni z<sub>i</sub> è attivo (vale 1) solo per una combinazione unica dei bit di selezione.

---
