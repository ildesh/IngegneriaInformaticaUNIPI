## Programmazione e assemblaggio

- Programma assemblato
		00d E897000
		0012 3C2D
		0014 7406
- Codice Assembler
		in_sgn: CALL inchair
		CMP $'-',%all

---
## Programma Assembler

Sezione dati:
- Dichiarazione di variabili
- Le variabili sono nomi simbolici per indirizzi di memoria che contencono i dati del programma
Sezione codice
- Istruzioni
In un programma ci sono:
- Direttive: che servono per l'assmblaggio e la dichiarazione di variabili
- Istruzioni

---
## Note sintattiche

- Ogni direttiva/istruzione occupa una riga, terminata da CR
- Anche l'ultima riga deve essere terminata da CR

```asm6502
.GLOBAL _main ;
.DATA
;...
.TEXT
main:       NOP
	....
			RET
```

L'assembler non è _case sensitive_ per le parole chiave del linguaggio, ma i nomi definiti dall'utente SONO _case sensitive_ 

>[!NOTE] Esempio: Conto dei bit a 1 in un long  
>![[CONTOBit_a_1_InUnLongEsempio.png]]  
>
>### Parliamone...  
>
>### Parte di sinistra (codice sorgente Assembly)  
>
>È un programma in **Assembly x86** che serve a **contare i bit a 1** presenti in una variabile di tipo `long`.  
>
>- **Sezione dati (`.DATA`)**  
>   - `dato: .LONG 0x0F0F0101` → variabile a 32 bit con valore esadecimale `0x0F0F0101`.  
>   - `conteggio: .BYTE 0x00` → variabile a 8 bit, inizializzata a 0, che conterrà il numero di bit a 1.  
>
>- **Sezione testo (`.TEXT`)**  
>   - `_main:` → etichetta della funzione principale.  
>   - `NOP` → istruzione vuota (nessuna operazione).  
>   - `MOVB $0x00, %CL` → azzera il registro `CL`, che verrà usato come contatore.  
>   - `MOVL dato, %EAX` → carica il valore di `dato` (32 bit) in `EAX`.  
>
>- **Ciclo (`comp:`)**  
>   - `CMPL $0x00, %EAX` → confronta `EAX` con 0.  
>   - `JE fine` → se `EAX == 0`, salta a `fine`.  
>   - `SHRL %EAX` → esegue uno **shift a destra logico** di `EAX`.  
>   - `ADCB $0x00, %CL` → aggiunge il bit meno significativo di `EAX` al contatore `CL` (conta i bit a 1).  
>   - `JMP comp` → torna all’inizio del ciclo.  
>
>- **Uscita (`fine:`)**  
>   - `MOVB %CL, conteggio` → salva in memoria (variabile `conteggio`) il numero di bit trovati.  
>   - `RET` → ritorna.  
>
>---
>
>### Parte di destra (traduzione in linguaggio macchina / codice oggetto)  
>
>È la **traduzione del sorgente in linguaggio macchina**, con gli indirizzi di memoria e i codici operativi esadecimali.  
>
>- **Esempio**:  
>   - A sinistra c’è `MOVB $0x00, %CL`  
>   - A destra corrisponde a `0x00000200: MOVB $0x00, %CL` (l’istruzione a quell’indirizzo in memoria).  
>
>La colonna di destra mostra quindi **indirizzi e istruzioni** così come il processore le esegue, con i salti già ricalcolati in base agli offset. In breve...
>
> - **A sinistra** → il programma Assembly scritto dal programmatore.
> - **A destra** → la versione tradotta in linguaggio macchina con gli indirizzi reali in memoria.
>
>>[!TIP] Note sintattiche
>>- Una riga di codice Assembler è fatta in questo modo:
>>	- ` nome:   KEYWORD operandi #commento [\CR]`
>>- Tutto può mancare, tranne il CR (simbolo per andare a capo).

---
## Direttive

###### `KEYWORD operandi [\CR]`
- Dichiarazione di variabili
	- `.BYTE`: riserva 1 byte
	- `.WORD`: riserva 2 byte
	- `.LONG`: riserva 4 byte

### Dichiarazione di variabili

| A     | B                         | commento                           |
| ----- | ------------------------- | ---------------------------------- |
| var 0 | .WORD                     | scalare, 2byte, valore 0x0000      |
| var 1 | .BTYE 0x30                | scalare, 1byte, valore 0x30        |
| var 2 | .BYTE 0x30, 0x31, ...     | vettoriale, 2 componenti da 1 byte |
| var 3 | .WORD 0x1020, 0x32AB, ... | vettoriale, 2 componenti da 2 byte |
| var 4 | .LONG var3+2              | scalare, 4 byte                    |
- .FILL numero, dim, espressione
	- Dichiara numero variabili di lunghezza dim e le inizializza ad espressione (default 0)
	- dim può essere 1(byte), 2(word), 4(long)
- Codifiche ASCII
$$
\text{var5: .BYTE 'C', 'i', 'a', 'o'}  \rightarrow  \text{vettoriale, 4 componenti da 1 byte}
$$
$$
\text{var5: .BYTE 0x43, 0x69, 0x61, 0x6F}
$$
- Vettori di byte inizializzati con codifiche ASCII
- Per indicare i caratteri speciali si usano le stesse sequenze di _escape_ che si usano in C++
- Variabili dichiarate una di seguito all'altra nella sezione dati sono consecutive in memoria
- se si usano variabili . BYTE, . WORD, . LONG, inserire sempre un'inizializzazione esplicita
- se non si vuole inizializzare una variabile, usare `.FILL`
#### Altre direttive

###### `.INCLUDE "path"
- include un file sorgente nel presente file
- L'assemblatore assembla un file unico contenente il codice di entrambi, Si mette, in genere, in cima o in fondo
###### `.SET nome, espressione
- Creare costanti simboliche. tali costanti hanno il nome `nome` ed il valore `espressione`. Ad esempio posso scrivere:

```asm6502
.SET dimensione, 4
. SET n_iter, (100*dimensione)
; ...
MOV $n_iter, %CX            ; op.immediato, ci vuole '$'
```

---
## Costanti numeriche

| tipo     | Descrizione                                                                                                       |
| -------- | ----------------------------------------------------------------------------------------------------------------- |
| naturali | no segno e vengono convertite nella loro rappresentazione in base 2                                               |
| intere   | hanno un segno davanti (+ o -) e vengono convertite nella loro rappresentazione in C2 sul numero di bit opportuno |
- I numeri possono essere scritti in base 2,8,10,16
	- in base 2 devono essere preceduti da 0b,
	- in base 8 devono cominciare per 0,
	- in base 10 non devono cominciare per 0,
	- in base 16 devono essere preceduti da 0x
- Quando non sono della dimensione giusta, vengono:
	- **Troncate** se troppo lunghe
	- **Estese** e normalmente l'assemblatore non ve lo dice

---
## Controllo di flusso

I costrutti di controllo di flusso dei linguaggi ad alto livello devono essere implementati in termini di **istruzioni di salto**
- if...then...else
- for...
- while...
- do...while

Conviene continuare a ragionare in termini di costrutti ad alto livello e tradurre in Assembler
- Si scrivono programmi più chiari e meglio verificabili

GUARDARE DIAPOSITIVA PER I CONTROLLI

---

