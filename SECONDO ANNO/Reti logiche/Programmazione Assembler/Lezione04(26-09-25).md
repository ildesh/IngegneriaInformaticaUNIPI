## Estensione di campo (per gli interi)

L'estensione di campo √® un operazione con cui si rappresenta un numero usando pi√π cifre.
- Banale per i naturali: aggiungere zeri in testa
	- 100110 $\rightarrow$ 0100110
- Non pu√≤ essere lo stesso per gli interi (perch√© il primo bit d√† il segno)
	- 100110 $\rightarrow$ 0100110
- Per gli interi, si deve ripetere il bit pi√π significativo
	- 100110 $\rightarrow$ 1100110 $\rightarrow$ $\rightarrow$ -(1100110 + 1)
	- 011011 $\rightarrow$ 0011011 $\rightarrow$ $\rightarrow$ -(0011001 + 1
### CONVERT WORD TO DOUBLEWORD in EAX


1. Formato: `CWDE`
2. Azione: Interpreta in contenuto di AX come un numero intero a 16bit, rappresenta tale numero su 32bit e quindi lo memorizza in EAX.
3. FLAG di cui viene modificato il contenuto: Nessuno

>[!TIP] Esempio:
> >[!CAUTION] Voglio sommare due numeri interi, uno si trova in AX ed uno in EBX
> 
> ```text
> MOV $-5, %AX
> MOV $100000, %EBX
> CWDE
> ADD %EAX, %EBX
> ```
> **Spiegazione:**
>
>1. `MOV $-5, %AX` ‚Üí inserisce il valore -5 (16 bit) in `AX`.
  >  
>2. `MOV $100000, %EBX` ‚Üí inserisce il valore 100000 in `EBX` (registro a 32 bit).
 >   
>3. `CWDE` (_Convert Word to Doubleword Extended_) ‚Üí copia il contenuto di `AX` in `EAX` propagando il segno (se `AX = -5`, allora `EAX = -5`).
  >  
>4. `ADD %EAX, %EBX` ‚Üí somma i due operandi: `EBX = EBX + EAX`.
  >  
>
>In questo caso:
>
>$$
> \text{EBX} = 100000 + (-5) = 99995
>$$
>

---
Perfetto üëç ti spiego meglio.

---

## Istruzioni di traslazione e rotazione

Le **istruzioni di traslazione (shift)** e di **rotazione (rotate)** agiscono a livello di **bit** su un operando (registro o cella di memoria).  
In pratica spostano i bit verso sinistra (**SX**) o verso destra (**DX**) per un certo numero di posizioni.
####  Formati

1. **`OPCODE src, dest`**
    - `src` = quante volte ripetere l‚Äôoperazione
        - pu√≤ essere un **immediato** (numero fisso, max 31), oppure il contenuto del registro **CL**
    - `dest` = l‚Äôoperando su cui agire (registro o memoria).
2. **`OPCODE dest`**
    - Se `src` non √® indicato, la traslazione/rotazione viene fatta **una sola volta**.
#### Differenza tra traslazione e rotazione

- **Traslazione (shift):** i bit ‚Äúspinti fuori‚Äù dall‚Äôestremo **si perdono** (alcune varianti li duplicano o li spingono nel Carry).
    
- **Rotazione (rotate):** i bit che escono da un lato **rientrano** dall‚Äôaltro (come una ruota che gira).

| Tipo       | Direzione | Sigla         | Comportamento                                                                       |
| ---------- | --------- | ------------- | ----------------------------------------------------------------------------------- |
| **Shift**  | Sinistra  | `SHL` o `SAL` | Sposta i bit a sinistra, riempie con 0 a destra. Equivale a moltiplicare per 2.     |
| **Shift**  | Destra    | `SHR`         | Sposta i bit a destra, riempie con 0 a sinistra. Equivale a divisione intera per 2. |
| **Shift**  | Destra    | `SAR`         | Sposta i bit a destra mantenendo il **segno** (bit pi√π significativo rimane).       |
|            |           |               |                                                                                     |
| **Rotate** | Sinistra  | `ROL`         | Ruota i bit verso sinistra, quello che esce a sinistra rientra a destra.            |
| **Rotate** | Destra    | `ROR`         | Ruota i bit verso destra, quello che esce a destra rientra a sinistra.              |
| **Rotate** | Sinistra  | `RCL`         | Ruota verso sinistra includendo il **Carry Flag** come ‚Äúbit aggiuntivo‚Äù.            |
| **Rotate** | Destra    | `RCR`         | Ruota verso destra includendo il **Carry Flag** come ‚Äúbit aggiuntivo‚Äù.              |

---
## SHIFT LOGICAL LEFT

1. Formato: `SHL source, destination` o `SHL destination`
2. Azione: Interpreta l'operando sorgente come un numero naturale n e, per n volte, sostituisce il bit contenuto in CF e ciascun bit dell'operando destinatario con il bit che gli √® immediatamente a destra, considerando il bit pi√π significativo dell'operando destinatario immediatamente a destra del bit contenuto in CF e sostituendo con 0 il bit meno significativo dell'operando destinatario
3. FLAGA di cui viene modificato il contenuto: TUTTI


| CF  | $\leftarrow$ | 15  | 14  | 13  | 12  | 11  | 10  | 9   | 8   | 7   | 6   | 5   | 4   | 3   | 2   | 1   | 0   |              |
| --- | ------------ | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ------------ |
|     | $\leftarrow$ | ‚óè   |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     | $\leftarrow$ |

|Operandi|Esempi|
|---|---|
|Immediato, Registro Generale|`SHL $1, %AX`|
|Immediato, Memoria|`SHLB $7, 0x00002000`|
|Registro CL, Registro Generale|`SHL %CL, %BX`|
|Registro CL, Memoria|`SHLL %CL, (%EDI)`|
|Memoria|`SHL (0x00400000)`|
|Registro Generale|`SHL %EAX`|
Lo shift sinistro n volte equivale a moltiplicare il destinatario per 2<sup>n</sup>  
- Vale in base 2 come in base 10  
Non √© segno di grande furbizia usare una MUL quando si pub usare una SHL 
- SHL √® pi√π veloce, e per un programmatore √® estremamente pi√π semplice 
CF viene sovrascritto n volte (difficile capire se il risultato corretto)

---
## SHIFT ARITHMETIC LEFT

---
## SHIFT LOGICAL RIGHT

---
## SHIFT ARITHMETIC RIGHT

---
## Divisioni intere

>[!WARNING] ATTENZIONE!
>Bisogna stare attenti alle approssimazione dei quozienti perch√©
> - **_IDIV_**: approssima per troncamento (verso lo zero)
> - **_SAR_**: approssima sempre a sinistra

Quindi SAR e IDIV danno lo stesso quoziente solo quando:
- Il dividendo √® **_positivo_**
	oppure
- La divisione d√† **_resto nullo_**

---
## Istruzioni di rotazione:

Queste istruzioni semplicemente **_ruotano i bit_**
1. Verso destra / sinistra
2. Includendo / non includendo CF nella rotazione
3. Hanno tutte lo stesso formato
>[!NOTE] In breve quali sono...
>![[IstruzioniDiRotazione.png]]
>
> - **Rotate LEFT (ROL)**:
> - **ROTATE RIGHT (ROR)**:
> - **ROTATE THROUGH CARRY LEFT, RCL**:
> - **ROTATE THROUGH CARRY RIGHT, RCR**:

---
### ROTATE LEFT

1. Formato: 


---
## Istruzioni Logiche

Queste applicano gli operatori dell'algebra di Boole (AND, OR, NOT) e in generale questi modificano i flag
Sono fondamentali per:
- Mascherare bit (`AND` con 0 o 1)
- Impostare bit (`OR`)
- Invertire bit (`NOT`)
- Effettuare operazioni di confronto bit a bit (`XOR`)
**Caratteristiche generali**:
- Operano **bit a bit**; ogni bit della destinazione viene calcolato separatamente.
- Aggiornano in genere solo alcuni **flag** (come **ZF, SF, PF**), mentre **CF** e **OF** vengono azzerati.
- Permettono manipolazioni efficienti per maschere, segnali e calcoli binari.

Approfondiamo i diversi tipi:
#### 1. NOT
- **Formato**:
    - `NOT destinazione` (pu√≤ essere un registro o una cella di memoria)
- **Azione bit a bit**:
    - Inverte tutti i bit della destinazione (`0 ‚Üí 1`, `1 ‚Üí 0`).
    - Non richiede un operando immediato.
- **Aggiornamento dei flag**:
    - **ZF, SF, PF** ‚Üí aggiornati secondo il nuovo valore
    - **CF, OF, AF, AF** ‚Üí **non modificati**
- **Esempi**:

| Operandi          | Esempi      |
| ----------------- | ----------- |
| Memoria           | `NOT [mem]` |
| Registro Generale | `NOT AX`    |

- **Note aggiuntive**:
    - Non cambia la dimensione del dato.
    - Utile per creare maschere inverse o complementi.
**Esempio pratico**:
`AX = 1011_0111_0100_0010b NOT AX AX -> 0100_1000_1011_1101b`

---

## 2. AND

- **Formato**:
    - `AND destinazione, sorgente`
- **Azione bit a bit**:
    - Esegue un **AND logico** tra ogni bit della destinazione e del sorgente.
    - Risultato = 1 solo se entrambi i bit = 1, altrimenti 0.
- **Aggiornamento dei flag**:
    - **ZF** ‚Üí 1 se risultato = 0
    - **SF** ‚Üí valore del MSB del risultato
    - **PF** ‚Üí 1 se numero di bit a 1 nel byte basso √® pari
    - **CF, OF** ‚Üí azzerati
- **Esempi**:

|Operandi|Esempi|
|---|---|
|Memoria, Registro Generale|`AND [mem], AX`|
|Registro Generale, Memoria|`AND AX, [mem]`|
|Registro Generale, Registro Generale|`AND AX, BX`|
|Immediato, Memoria|`AND [mem], 0FFh`|
|Immediato, Registro Generale|`AND AX, 0FFh`|

- **Note aggiuntive**:
    - Molto usato per **mascherare bit** (es. `AND AX, 0x0F` per mantenere solo i 4 bit bassi).
    - Equivalente a un ‚Äúfiltro‚Äù: 0 elimina, 1 mantiene.

**Esempio pratico**:
`AX = 1011_0111_0100_0010b BX = 1111_0000_1111_0000b AND AX, BX AX -> 1011_0000_0100_0000b`

---

## 3. OR
- **Formato**:
    - `OR destinazione, sorgente`
- **Azione bit a bit**:
    - Esegue un **OR logico** tra ogni bit della destinazione e del sorgente.
    - Risultato = 1 se almeno uno dei due bit = 1, altrimenti 0.
- **Aggiornamento dei flag**:
    - **ZF, SF, PF** ‚Üí aggiornati come AND
    - **CF, OF** ‚Üí azzerati
- **Esempi operandi**:
`OR AX, BX OR [mem], AX OR AX, 0FFh`
- **Note aggiuntive**:
    - Utile per **impostare bit** senza modificare gli altri.
    - Pu√≤ essere visto come ‚Äúaccensione selettiva‚Äù dei bit.
**Esempio pratico**:
`AX = 1011_0111_0100_0010b BX = 1111_0000_1111_0000b OR AX, BX AX -> 1111_0111_1111_0010b`

---

## 4. EXCLUSIVE OR (XOR)
- **Formato**:
    - `XOR destinazione, sorgente`
- **Azione bit a bit**:
    - Esegue un **XOR logico**: 1 se i bit sono diversi, 0 se uguali.
    - Sintassi: `A XOR B = (A AND NOT B) OR (NOT A AND B)`
- **Aggiornamento dei flag**:
    - **ZF, SF, PF** ‚Üí aggiornati come AND/OR
    - **CF, OF** ‚Üí azzerati
- **Esempi operandi**:
`XOR AX, BX XOR [mem], AX XOR AX, 0FFh`
- **Note aggiuntive**:
    - Utile per **invertire selettivamente bit** usando maschere.
    - `XOR AX, AX` azzera il registro in modo molto efficiente.
**Esempio pratico**:
`AX = 1011_0111_0100_0010b BX = 1111_0000_1111_0000b XOR AX, BX AX -> 0100_0111_1011_0010b`
### Utilizzi delle istruzioni logiche

---
## Istruzioni di controllo

Il flusso del programma prosegue normalmente in sequenza
Le istruzioni stanno in memoria consecutivamente
Il processore preleva un'istruzione, incrementa EIP, la esegue
- quindi si eseguono le istruzioni una dietro l'altra
Tranne quando un istruzione di controllo scrive un nuovo valore in EIP
- Il flusso sequenziale si interrompe, e si "salta" al nuovo punto
Istruzioni di salto (JMP, Jcon)
Istruzioni per la gestione di sottoprogrammi (CALL; RET)

---
### JUMP
1. Formato: `JMP %EIP += displacement / JMP *extended_register / JMP *memory
2. Azione: Calcola un indirizzo di salto e lo immette nel registro EIP
3. FLAG di cui viene modificato il contenuto: Nessuno
In Assembler si usa un **un nome simbolico** per indicare l'istruzione dove si deve saltare, quindi non √® necessario aver presente il formato di indirizzamento

>[!CAUTION]
>Se dovessi scrivere 
> ```
> PIPPO:
> 	JMP PIPPO
> ```
>
> - Succede un **loop infinito**:
>
>	- Il registro **EIP** viene continuamente aggiornato con lo stesso indirizzo di PIPPO.
>	
>	- La CPU **non esegue altre istruzioni** al di fuori del loop.	
>	
>	- Nessun flag viene modificato, quindi il programma resta ‚Äúbloccato‚Äù in quel punto.
 
---
### JUMP if CONDITION MET
1. Formato: `Jcon %EIP += displacement`
2. Azione: Esamina il contenuto dei flag. Se da questo esame risulta che la condizione con √® soddisfatta, allora si comporta come l'istruzione `JMP %EIP ¬± displacement`; in caso contrario termina senza compiere alcuna azione.
3. FLAG di cui viene modificato il contenuto: Nessuno
---

>[!NOTE] Esempi di condizione
> ![[JUMPifCONDITION.png]]

>[!TIP] Esempi di codice che usa salti con condizioni sui flag
>![[JUMPifCONDITION2.png]]

---
>[!NOTE] Esempi di condizioni di confronto tra numeri naturali
>![[JUMPifCONDITION3.png]]

>[!TIP] Esempi di codice che usa salti con condizioni di confronto tra naturali
> ![[JUMPifCONDITION4.png]]

---
>[!NOTE] Condizioni di confronto tra numeri interi
>![[JUMPifCONDITION5.png]]

>[!TIP] Esempi di codice che usa salti con condizioni di confronto tra interi
>![[JUMPifCONDITION6.png]]
>
>La condizione scritta nell'OPCODE si riferisce al destinatario

---
4. Salti condizionati con condizioni di _confronto_ **seguono sempre una CMP** in ogni programma sensato
5. Le relazioni di confronto tra naturali **si evincono sempre dai flag**
	1. Esempio: **_jump if below or equal_**
		```asm6502
		CMP src, dest
		JBE
		```

6. La CMP sottrae src da dest (SUB)
	1. Se dest=src, il risultato √® nullo (ZF = 1)
	2. Se dest < src, la sottrazione genera un prestito (CF = 1)
	3. JBE quindi testa la seguente condizione: **ZF = 1 OR CF = 1**
7. Anche per le condizioni sugli interi si guardano i **flag**
	1. Esempio: **_jump if greater or equal_**
8. La CMP sottrae src da dest
	1. Se la differenza √® <u>rappresentabile</u>, OF = 0. 
		1. Affinch√© dest $\geq$ src, il segno del risultato deve essere positivo (SF = 0)
	2. Se la differenza non √® rappresentabile, OF = 1. In questo caso il segno del risultato √® sbagliato.
		1. Affinch√© dest $\geq$ src, il segno del risultato deve essere negativo (SF = 1)
	3. JGE quindi salta se √® vera la seguente condizione: OF = SF

>[!NOTE] RICORDA BENE!
>Non necessario ricordarsi le condizioni sui flag. Basta conoscere i codici mnemonici, che sono facili da ricordar
>

---
## Sottoprogrammi

Le istruzioni coinvolte sono due:
1. **CALL** :  salta ad un sottoprogramma
2. **RET** :    ritorna al programma chiamante
Entrambe fanno riferimento alla **pila**.

---
### CALL
1. Formato: `CALL%EIP += $ / CALL *extended_register / CALL *memory`
2. Azione: Effettua Ia chiamata di un sottoprogramma. Pi√π precisamente, salva nella pila corrente il contenuto del registro EIP e poi modifica il contenuto di tale registro in modo del tutto simile a come fa l'istruzione JMP.
3. FLAG di cui viene modificato il contenuto: Nessuno

---
### RETURN
1. Formato: `RET`
2. Azione: Effettua il ritorno da un sottoprogramma. Pi√π precisamente, rimuove un long dalla pila e con esso rinnova il contenuto di EIP.
3. FLAG di cui viene modificato il contenuto: Nessuno

---
### NO OPERATION
1. Formato: `NOP`
2. Azione: Termina senza compiere alcuna azione
3. FLAG di cui viene modificato il contenuto: Nessuno
	1. Serve per perdere tempo...

---
### HALT
1. Formato: `HLT`
2. Azione: Provoca la cessazione di ogni attivit√† del processore:
	1. II processore alterna la fase di fetch (in cui preleva un'istruzione) con quella di esecuzione dell'istruzione che ha prelevato. Quando preleva un'istruzione HLT, smette di fare qualunque cosa, e si pone in una condizione dalla quale si pub uscire solo resettando la macchina.

---
## Protezione & Istruzioni privilegiate

- Il processore pu√≤ funzionare in due modalit√†: **utente** e **sistema**
- In modalit√† sistema pu√≤ usare **tutte le istruzioni**
- In modalit√† utente ne pu√≤ usare **soltanto alcune**
- Tra le istruzioni che non potete utilizzare ci sono quelle "privilegiate":
	- HLT
	- IN
	- OUT