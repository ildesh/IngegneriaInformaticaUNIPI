## Tempo di esecuzione di un programma

Il **tempo di esecuzione effettivo** di un programma non è semplicemente il numero di istruzioni diviso la frequenza di clock. Ci sono diversi fattori che lo influenzano:
- **Il clock non va a velocità costante**  
    Oggi le CPU usano tecniche come _dynamic frequency scaling_ (es. Intel SpeedStep, AMD Cool’n’Quiet, Turbo Boost) che alzano o abbassano la frequenza in base a temperatura, carico di lavoro, consumo energetico.
- **Il vostro processo non necessariamente gira su un solo core**  
    Un processo può essere spostato dal sistema operativo da un core a un altro (_CPU scheduling_). Questo comporta effetti di cache miss (perdita di dati caricati nella cache del core precedente) e tempi diversi di esecuzione.
- **Mille altri meccanismi che introducono variabilità**
    - **Pipeline e branch prediction**: se ci sono _stalli_ o salti mal predetti, il tempo di esecuzione aumenta.
    - **Cache hierarchy**: l’accesso alla memoria può variare di ordini di grandezza (L1 cache nanosecondi, RAM centinaia di ns).
    - **Interruzioni (interrupts)**: il processore può essere interrotto da eventi hardware/software che sospendono temporaneamente il programma.
    - **Contesa delle risorse**: se più processi usano bus, memoria o periferiche, il tempo varia.
    - **Sistema operativo**: lo scheduler può sospendere il processo e far girare altri task, introducendo latenza.
    - **Hyper-threading / SMT**: due thread sullo stesso core condividono alcune unità di esecuzione, rallentandosi a vicenda.

---
## Tempo di esecuzione delle istruzioni

Questo dipende molto dall'architettura del processore (anche all'interno della stessa famiglia) ma in generale:
- Istruzioni operative della ALU ( (I)MUL / (I)DIV ) costano 'poco': `O(1) clock` ovvero, poche latenze e throughput elevato.
- (I)MUL / (I)DIV costano 'molto': `O(10) clock` o più cicli di clock, a seconda della microarchitettura.

>[!TIP] Per evitare moltiplicazioni e divisioni possiamo usare:
>- **_Shift_**: X · 10 $\rightarrow$ X · 8 + X · 2
>	- cioè due shift e un’addizione.
>- **_LEA_** (Load Effective Address): 
>	- Calcola dest = disp + base + indice · scala
>	- es. z = 16 · 3 + 3 · y-13500 può essere codificato in una sola istruzione LEA.
>
> I compilatori usano trucchi del genere e quando in c++ scriviamo a = b · c vuol dire che il compilatore non si limita a tradurre in una `MUL`, ma se `c` è costante come `2,4,8` usa uno **shift**, se è combinazione semplice (es. `10`) la scompone in somme e shift (`b*10 → (b<<3)+(b<<1)`), e se possibile usa una **LEA** per calcolare l’espressione senza ALU.

---
# NUOVO ARGOMENTO - Note sull'Assembler e
## Processore a 32 bit

- **Registri generali (EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP)** → 32 bit.
- **Registri speciali**:
    - EIP (instruction pointer, 32 bit),
    - EFLAGS (registro dei flag, 32 bit).

---
## Processore a 64 bit

Con l’architettura x86-64:
- **Registri generali** estesi a 64 bit con prefisso `R` (RAX, RBX, RCX, …).
- **Nuovi registri**: `R8–R15`.
- Ogni registro è accessibile anche a:
    - 32 bit (`EAX`),
    - 16 bit (`AX`),
    - 8 bit (`AL`, `AH`),
    - oppure `r8d`, `r8w`, `r8b` per i registri aggiuntivi.
- **Registri speciali**:
    - RIP (instruction pointer, 64 bit).
    - RFLAGS (registro dei flag, 64 bit).
        - I flag principali (ZF, SF, CF, OF, …) mantengono la stessa posizione.

---
# Spazio di memoria (x86-64)

- In teoria → 2⁶⁴ byte indirizzabili.
- In pratica, solo **48 o 57 bit** di indirizzamento reale:
    - Gli indirizzi devono essere in **forma canonica** → i bit oltre il 47 (o 56) devono ripetere il valore del bit 47.
    - Violare questa regola → _#GP fault_ (General Protection).

---
# Modifiche all’Assembler in x86-64

- **Suffissi per dimensione operandi**:
    1. `B` (byte, 8 bit)
    2. `W` (word, 16 bit)
    3. `L` (long, 32 bit)
    4. `Q` (quad, 64 bit)
- **Indirizzamento di memoria**:
    $$\pm \text{displacement(base,indice,scala)}$$
    - Scala ammessa: 1, 2, 4, 8.
    - Base/indice = registri generali 64 bit.
    - Displacement = costante intera a 32 bit.
- **Immediati**:
    - Non si possono avere immediati a 64 bit _diretti_ in tutte le istruzioni.
    - Eccezione: l’istruzione speciale `MOVABS`.

---
# MOVABS

- `MOVABS` consente di caricare **costanti a 64 bit** in un registro.
    - Esempio:
        `movabs $0x123456789ABCDEF0, %rax`
- Necessaria perché la normale `MOV` accetta solo immediati a 32 bit (che vengono estesi a 64).

#### Esempio di un programma

---
## Altre modifiche all'assembler

Con l’estensione a 64 bit ci sono alcuni cambiamenti nelle istruzioni esistenti:
- **_LOOP, REPx e contatori di stringa_**: le istruzioni di ripetizione (`LOOP`, `REP`, `REPE`, `REPNE`) e le operazioni su stringhe (`MOVS`, `CMPS`, `SCAS`, ecc.) usano:
	- in modalità 32 bit → **ECX** come contatore;
	- in modalità 64 bit → **RCX** come contatore.
	- Esempio:

	```asm6502
	mov $10, %rcx rep movsb ; copia 10 byte da RSI a RDI
	```
	
- **_Moltiplicazione a 64 bit( (I)MUL ): **RDX_RAX $\leftarrow$ RAX · source** e esce fuori un risultato a 128 bit che viene memorizzato in **RDX:RAX**.
```asm6502
mov $5, %rax 
mul %rbx ; RDX:RAX = RAX * RBX
```

	- Con IMUL (signed): stesso comportamento, ma il prodotto è con segno.
	- Esiste anche la variante a 2/3 operandi per IMUL che scrive direttamente in un registro a 64 bit (senza usare RDX).

- **_Divisione a 64 bit ( (I)DIV )_**: Dividendo in RDX_RAX, Q in RAX e R in RDX e dividendo dunque a 128 bit → contenuto in **RDX:RAX**.
- Istruzioni di traslazione e rotazione: `SHL`, `SHR`, `SAR`, `ROL`, `ROR`, `RCL`, `RCR` → supportano operandi a 64 bit.
	- L’operando sorgente (il numero di bit da shiftare) è preso da:
    - un immediato, oppure
    - il registro **CL** (parte bassa di RCX).

>[!WARNING] Regola importante:
>- Il numero di shift è sempre **mascherato a 6 bit** (0–63).
> 
>- Quindi, se metti `mov $130, %cl`, in realtà verrà usato **130 mod 64 = 2**.

>[!TIP] Esempio:
>```asm6502
>mov $65, %cl 
>shl %cl, %rax   ; in realtà fa shift di 1 (65 mod 64)
>```

---
