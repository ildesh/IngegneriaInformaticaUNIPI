## Codifica macchina e codifica mnemonica

- La **_Codifica macchina_** rappresenta una serie di zeri e di uni che codificano le istruizoni che il processore esegue
- La **_Codifica mnemonica_** rappresenta un modo simbolico di scrivere quelle serie di zeri e di uni che codificano le istruzioni che il processore esegue
- Il linguaggio Assembler usa una codifica mnemonica delle istruzioni e dispone di una serie di sovrastrutture sintattiche che lo rendono più semplice da usare da un programmatore (nomi simbolici per locazioni di memoria ad esempio)

---
### Istruzioni in codifica mnemonica

- Le istruzioni constano in 3 campi:
    1. **Codice operativo** stabilisce quale è l'operazione che deve essere eseguita;
    2. **Sufflisso di lunghezza** stabilisce quanto sono lunghi gli operandi dell'istruzione (es. byte), quando un'istruzione ammette operati di lunghezza diversa;
    3. **Operandi** sono i dati su cui l'istruzione deve operare (es. gli addendi).
   
Gli operandi possono essere contenuti in registri, celle di memoria, porte di I/O, direttamente nell'istruzione (costanti).

Le istruzioni ammettono **zero, uno o due operandi**.
- Se due, il primo e' **sorgente**, il secondo e' **destinatario**.
  - Il sorgente non viene modificato dall'istruzione, il destinatario si e viene sostituito con il risultato dell'elaborazione.
- Se uno, può essere **sorgente** o **destinatario** a seconda dell'istruzione.
Se ci sono due operandi sono ella stessa lunghezza (tranne qualche eccezione).

---
#### Primo esempio di programma:

>[!TIP] Consegna.
> - **Preleva** dalla memoria un operando a 32 bit, che si trova a partire dall'indirizzo 0x00000100
> - **Conta** il numero di bit a 1 nell'operando
> - **Scrivi** il risultato (numero di bit a 1) in memoria a partire dall'indirizzo 0x00000104

Si tratta di fare bit counting (contare quanti bit a 1 ci sono in una word) e poi scrivere il risultato in memoria.

Mettiamolo a confronto anche con C++

```cpp
#include <iostream>
using namespace std;

int main() {
    unsigned int* indirizzo = (unsigned int*)0x00000100;

    // Preleva l’operando dalla memoria
    unsigned int x = *indirizzo;

    // Conta i bit a 1
    unsigned int count = 0;
    for (int i = 0; i < 32; i++) {
        if (x & (1u << i)) {
            count++;
        }
    }

    // Scrive il risultato in memoria all'indirizzo 0x00000104
    *((unsigned int*)0x00000104) = count;

    return 0;
}

```

![Esempio di programma (cont)](primoprogramma.png)

```asm6502
  MOVB $0x00, %CL  // Copia la costante 0 in CL
  
  MOVL 0x00000100, %EAX  // Sposta 32bit dalla memoria all'indirizzo 0x00000100 in EAX
    // In EAI c'è il contenuto delle quattro celle
  
  CMPL $0x00000000, %EAX
  
  JE %EIP+0x07  // Jump if equal da qualche parte. se dentro if go 1 salta a EIP+7 ovvero 206 + 7 = 213
  
  SHRL %EAX  // Sposta un bit, l'LSB va in CF
  
  ADCB $0x00, %CL  // Incrementa CL se CF=1
  
  JMP %EIP-$0x0C  // Ripeti
  
  MOVB %CL, 0x00000104  // Scrivi il risultato in memoria
  
  HLT  // Ferma il programma
```

---
## Istruzioni Assembler

- **Operative**: quelle che svolgono qualche compito (ADC,SHR,MOV,CMP)
- **Di controllo**: quelle che modificano il flusso di esecuzione del programma (JMP,JE,HLT)

>[!NOTE]
> LE istruzioni di controllo sono più o meno tutte qui
> - Si salta: JMP;
> - Si salta o no, sulla base del contenuto di un flag.

---
## Indirizzamento delle istruzioni operative

$$
\text{OPCODE size source} \text{, destination}
$$  
-  **OPCODE**: codice operativo
- **Size**: spesso può essere omesso, in questo caso si assume la lunghezza di default
- **Source**, **destination**: individuati tramite **modi di indirizzamento** (addressing modes)

### Modi di indirizzamento
#### 1. Indirizzamento di registro

- Uno tra:
  - 8 registri generali a 32 bit (EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP)
  - 8 registri generali a 16 bit (AX, BX, CX, DX, SI, DI, BP, SP)
  - 8 registri generali a 8 bit (AL, BL, CL, DL, AH, BH, CH, DH)
- SI applica sia al sorgente che al destinatario

>[!TIP] Esempio:
> ```asm6502
> OPCODE %DI ; 16bit
> OPCODE %EAX, %EBX ; 32bit
> OPCODE %AH, %CL ; 8bit
>
> ; il simbolo % viene usato per indicare un registro
> ```

#### 2. Indirizzamento immediato

- Solo per l'operando sorgente

>[!TIP] Esempio:
> ```asm6502
> OPCODE $0x20, %AL ; 8bit
> OPCODE $0x5683A20B, %ECX ; 32bit
>
> ; il $ viene usato per indicare un valore immediato
> ```

#### 3. Indirizzamento di memoria

L’indirizzamento di memoria è il modo in cui un processore accede ai dati in memoria. Ogni cella di memoria ha un indirizzo univoco, e le istruzioni del processore devono specificare dove leggere o scrivere i dati.

In altre parole, l’indirizzamento dice al processore “da quale indirizzo prendere il dato” o “dove memorizzarlo”.

E' necessasrio specificare un di memoria a 32 bit

Il caso più generale: 

>[!CAUTION] Caso più generale:
>$$
>\text{Indirizzo} = | \text{ Base} + (\text{Indice} \times \text{Scala}) \pm \text{Displacement } |_{2^{32}}
>$$

Esistono diversi modi di indirizzamento di memoria:
1. **Indirizzamento diretto**: l'istruzioe specifica l'indirizzo di memoria del dato.
  - Il proceossre va direttamente a quell'indirizzo per leggere o scrivere
  
  >[!TIP] Esempio:
  > ```asm6502
  > MOV A, [1000h] ; Legge il contenuto dell’indirizzo 1000h nel registro A
  > MOV [2000h], B ; Scrive il contenuto del registro B nell’indirizzo 2000h
  > ```
  
2. **Indirizzamento indiretto**: l'istruzione specifica un registro che contiene l'indirizzo di memoria del dato. 
	- Utile quando l'indirizzo può cambiare durante l'esecuzione (quindi in maniera dinamica)

  >[!TIP] Esempio:
  > ```asm6502
  > MOV BX, 1000h ; Carica l’indirizzo 1000h nel registro BX
  > MOV A, [BX] ; Legge il contenuto dell’indirizzo memorizzato in BX nel registro A
  > ```

3. **Indirizzamento con displacement e registro di modifica**
4. **Indirizzamento bimodificato senza displacement**
5. **Indirizzamento bimodificato con displacement**

---
### Indirizzamento delle porte di I/O
- Uno dei due operandi (mai entrambi) può trovarsi nello spazio di I/O
- Indirizzamento diretto:
  - Si può usare solo per indirizzi <256 = 8bit
  - Perché nel formato macchina ci sono solo 8 bit per l'indirizzo di I/O
- Indirizzamento indiretto con registro puntatore:
  - Si può usare solo il registro DX ovvero il registro a 16 bit.
  
  >[!TIP] Da sapere, per curiosità:
  >In architettura x86:
  > - DX è un registro a 16 bit.
  > - Può essere diviso in due registri da 8 bit:
  >   - DH → byte alto (high) di DX
  >   - DL → byte basso (low) di DX
  > Quindi:
  > $$ \text{DX} = \text{DH} \times \text{DL} = \text{16} $$

---
## Nota sulla sintassi

- Gli operandi immediati sono preceduti da `$`
- I registri sono preceduti da `%`
- in un'istruzioni, un numero non preceduto dal `$` è un **indirizzo di memoria(indirizzamento diretto)**, non una costante.
- Suffissi:
  - `B` per byte (8 bit)
  - `W` per word (16 bit)
  - `L` per long (32 bit) 
- Possono essere omessi se uno degli operandi è un **_registro_**
  - in questo caso, la dimensione del registro rende l'istruzione non ambigua
- Altrimenti va specificato (l'assemblatore dovrebbe dare errore se manca)
  - Esempi:
    - `MOVB $0x20, %AL` (8 bit)
    - `MOVL $0x12345678, %EAX` (32 bit)
    - `MOVW 0x1000, %AX` (16 bit)
    - `MOV 0x1000, %EAX` (32 bit, perché EAX è a 32 bit)
    - `MOV 0x1000, %AX` (16 bit, perché AX è a 16 bit)
    - `MOV 0x1000, %AL` (8 bit, perché AL è a 8 bit) 
  
---
## Principali istruzioni: (DAFINIRE DA QUI IN POI)
- **Istruzioni operative**:
  - **Istruzioni di trasferimento dati**
  - **Istruzioni aritmetiche**
  - **Istruzioni logiche**
  - **Istruzioni di traslazione/rotazione**
- **Istruzioni di controllo**
  - **Istruzioni di salto**
  - **Istruzioni per la gestione di sottoprogrammi** 

---
#### Istruzioni di trasferimento

1. "spostano" bit da una parte a un'altra
	- Memoria $\leftrightarrow$ registro
	- Registro $\rightarrow$ registro
	- I/O $\leftrightarrow$ registro
2. Non esistono altre possibilità	
	- es. non esiste trasferimento memoria $\rightarrow$ memoria
	- Si passa da un registro del processore, ci vogliono due istruzioni
	- Salvo eccezioni che vedremo più avanti (istruzioni stringa)
3. Nessuna di queste modifica i flag

---
## MOVE

- **Formato**:  
    `MOV destinazione, sorgente`  
    (reg ↔ reg, mem ↔ reg, reg ↔ mem, imm → reg/mem)
- **Azione**: Copia il contenuto della sorgente nella destinazione.
- **Flag**: Nessun flag modificato.
    
---
## LOAD EFFECTIVE ADDRESS (LEA)

- **Formato**:  
    `LEA reg, [indirizzo_effettivo]`
- **Azione**: Calcola l’indirizzo effettivo dell’operando e lo memorizza nel registro (senza leggere la memoria).
- **Flag**: Nessun flag modificato.

---
## EXCHANGE (XCHG)

- **Formato**:  
    `XCHG operando1, operando2`  
    (reg ↔ reg, reg ↔ mem, mem ↔ reg)
- **Azione**: Scambia i valori dei due operandi.
- **Flag**: Nessun flag modificato.

---
## INPUT (IN)

- **Formato**:
    - `IN AL, imm8` → legge da porta a 8 bit in AL
    - `IN AX, imm8` → legge da porta in AX (16 bit)
    - `IN EAX, DX` → legge da porta specificata in DX (32 bit)
- **Azione**: Legge un dato da una porta di I/O e lo mette nel registro specificato.
- **Flag**: Nessun flag modificato.
    

---

## OUTPUT (OUT)

- **Formato**:
    - `OUT imm8, AL` → scrive AL su porta imm8
    - `OUT imm8, AX` → scrive AX su porta imm8
    - `OUT DX, EAX` → scrive EAX su porta specificata in DX
- **Azione**: Scrive un dato dal registro verso una porta di I/O.
- **Flag**: Nessun flag modificato.

---
### Input, Output, non ortogonalità

Uniche due istruzioni che riguardano l'I/O;
- Gli operandi nell'I/O si possono solo trasferire nei/dai registri generali
- Eventuali operazioni si fanno nel processore, non nelle porte
Input ed output usano soltanto
- I registri AL, AX come sorgente/destinatario
- DX come registro puntatore
L'assembler non è ortogonale
- Il C++ è ortogonale. Se la sintassi mi consente di scrivere una variabile, ci posso mettere qualunque variabile.
- L'Assembler no. Se posso fare una cosa con un registro generale, non è detto che la possa fare con gli altri 

