## La pila (stack)

La pila è una zona di memoria gestita Last In First Out (LIFO) ed è essenziale al funzionamento del calcolatore.
1. Serve a poter annidare sottoprogrammi
2. L'assembler è organizzato per sottoprogrammi
3. Prima di "saltare" al sottoprogramma salvo l'indirizzo di ritorno ( - quello della prossima istruzione) nella pila (PUSH)
4. Al termine del sottoprogramma, per tornare dove ero, faccio una POP della pila
5. Il registro ESP (stack pointer) serve come puntatore al top della pila
	- Quindi non va usato per altri scopi
6. PUSH valore
	- Decrementa ESP
	- Copia valore in (%ESP)
7. POP destinatario
	- Copia (%ESP) in destinatario
	- Incrementa ESP
8. ESP va inizializzato prima che parta il programma

>[!NOTE] Da notare
>![[Programma principale-Sottoprogramma-Pila.png]]
> Questa immagine rappresenta **come funziona la chiamata di un sottoprogramma (o funzione/procedura) in un linguaggio a basso livello** e come la **pila di esecuzione (stack)** gestisce il flusso del programma.

>[!TIP] Spiegazione dell'immagine sopra
>
>1. **Programma principale**
>
> 	  - Esegue normalmente il suo codice (istruzioni in sequenza).  
> 	  - A un certo punto incontra una **chiamata a sottoprogramma** (in rosso).  
> 	  - In quel momento deve “ricordarsi” dove tornare una volta terminato il sottoprogramma: questa informazione viene messa nella pila.
>
>2. **Sottoprogramma**
>
> 	  - Dopo la chiamata, il controllo passa alla **prima istruzione del sottoprogramma** (in verde).  
> 	  - Viene eseguito il codice del sottoprogramma.  
> 	  - Alla fine c’è l’istruzione **“ritorno al chiamante”** (in rosso): grazie alla pila, il programma sa esattamente **dove riprendere l’esecuzione** nel programma principale.
>
>3. **Pila (Stack)**
>
> 	  - La pila è una struttura dati LIFO (Last In, First Out).  
> 	  - Quando viene chiamato un sottoprogramma:  
> 	    - Si salva in cima alla pila la **Prima Istruzione di Ritorno (P.I.R.)**, cioè l’indirizzo del punto del programma principale dove continuare dopo il sottoprogramma.  
> 	    - Spesso si salvano anche altre informazioni di contesto (**Stato Interno di Ritorno, S.I.R.**) come registri, variabili temporanee ecc.  
> 	  - Alla fine del sottoprogramma:  
> 	    - Si estrae dalla pila l’indirizzo di ritorno.  
> 	    - L’esecuzione riprende esattamente da lì.

---
## PUSH

1. Formato: 
 ```asm6502 
 PUSH source 
 ```
2. Azione: Salva nella pila corrente una copia dell'operando sorgente (che deve essere a 16 0 a 32 bit). Più in dettaglio, compie le seguenti azioni: 
	1. decrementa l'indirizzo contenuto nel registro ESP di due o di quattro;
	2. memorizza una copia dell'operando sorgente nella doppia o quadrupla locazione il cui indirizzo contenuto in ESP.
3. FLAG di cui viene modificato il contenuto: NESSUNO

| Operando          | Esempi          |
| ----------------- | :-------------- |
| Memoria           | POPW 0x02AB2000 |
| Registro Generale | POP %BX         |
### PUSHAD / POPAD
####  **_1. PUSHAD_**

1. Formato
 ```asm6502 
 PUSHAD
 ```

2. Azione: Salva nella pila corrente una copia del contenuto degli 8 registri generali a 32 bit, rispettando il seguente ordine: EAX, ECX, EDX, EBX, ESP, EBB ESI, EDI.

3. FLAG di cu viene modificato il contenuto: NESSUNO
#### **_2. POPAD_**

1. Formato
 ```asm6502 
 POPAD
 ```

2. Azione: Rimuove da19apila 8 long e con essi rinnova il contenuto degli 8 registri generali a 32 bit, rispettando il seguente ordine: EDI, ESI, EBP, ESP, EBX, EDX, ECX, EAX.

3. FLAG di cu viene modificato il contenuto: NESSUNO
	1. Si noti che ESP **non viene sovrascritto** (sarebbe un problema se lo fosse)

---
## Istruzioni Aritmetiche

- **Alcune (non tutte)** considerando gli operandi indifferentemente come naturali e come **numeri interi**
	- L'istruzione di **somma** esegue quindi l'algoritmo giusto quale che sia l'interpretazione delle stringhe di bit che le vengono passate come operandi.
- **_Modificano i flag_**
	- Considerano due algoritmi: uno che va bene per operandi **naturali**, ed uno che va bene per **interi**
	- I flag da guardare sono diversi (CF per naturali, SF/OF per interi)
- Il programmatore è **_l'unico che sa cosa sta scrivendo_**
	- Se una certa stringa di bit è un naturale o un intero
	- Il programmatore farà seguire queste istruzioni da qualche altra istruzione che va a guardare i **flag giusti**

---
### ADD

 1. Formato
 ```asm6502 
 ADD source, destination
 ```

2. Azione: Modifica l'operando destinatario sommandovi l'operando sorgente (il risultato dell'operazione consistente sia se gli operandi sono interpretati come numeri naturali sia se gli operandi sono interpretati come numeri interi); mette ad 1 il contenuto del flag CF se, interpretando gli operandi come numeri naturali, si verificato un riporto; mette ad 1 il contenuto del flag OF se, interpretando gli operandi come numeri interi, si verificato un traboccamento.

3. FLAG di cu viene modificato il contenuto: TUTTI

| Operandi                             | Esempi               |
| ------------------------------------ | -------------------- |
| Memoria, Registro Generale           | ADD 0x00002000, %EDX |
| Registro Generale, Memoria           | ADD %CL, Ox12AB1024  |
| Registro Generale, Registro Generale | ADD %AX %DX          |
| Immediato, Memoria                   | ADDB $0x5B, (%EDI)   |
| Immediato, Registro Generale         | ADD $0x54A3, %AX     |
4. è come se scrivessi `dest += src` in C++
5. Le somme si fanno nello stesso modo in qualunque base:
6. Supponiamo operandi a 3 cifre per semplicità

>[!NOTE] Somma in decimale
>$$
>\begin{array}{r}
>   \ \,724 \\
>+ \, 839 \\ \hline
>  1563
>\end{array}
>$$

>[!NOTE] Somma in binario
>$$
>\begin{array}{r}
>   \ \,101 \\
>+ \,011 \\ \hline
>  1000
>\end{array}
>$$

---
### INCREMENT

1. Formato
```asm6502 
INC destination
```

2. Azione: Equivale all'istruzione `ADD $1, destination`, con la sola differenza che il contenuto del flag CF non viene modificato.

3. FLAG di cu viene modificato il contenuto: OF, SF e ZF

| Operandi          | Esempi      |
| ----------------- | ----------- |
| Memoria           | INCB (%ESI) |
| Registro Generale | INC %CX     |
4. Più compatta, in quanto nella ADD andrebbe comunque specificata una costante sul numero di bit del destinatario (8, 16, 32) 
5. Tanti (tanti) anni fa, era anche più veloce

---
### SUBTRACT

1. Formato: `SUB source, destination`
2. Azione: Modifica l'operando destinatario sottraendovi l'operando sorgente (il risultato dell'operazione consistente sia se gli operandi sono interpretati come numeri naturali sia se gli operandi sono interpretati come numeri interi); mette ad 1 il contenuto del flag CF se, interpretando gli operandi come numeri naturali, si verificato un prestito; mette ad 1 il contenuto del flag OF se, interpretando gli operandi come numeri interi, si verificato un traboccamento.
3. FLAG di cu viene modificato il contenuto: TUTTI

| Operandi                        | Esempi                    |
|---------------------------------|---------------------------|
| Memoria, Registro Generale      | `SUB 0x00002000, %EDX`    |
| Registro Generale, Memoria      | `SUB %CL, 0x12AB1024`     |
| Registro Generale, Registro Generale | `SUB %AX, %DX`       |
| Immediato, Memoria              | `SUBB $0x5B, (%EDI)`      |
| Immediato, Registro Generale    | `SUB $0x543, %AX`         |

4. La SUB calcola `dest -= src` 
5. Algoritmo indipendente dalla base

>[!NOTE] Differenza in decimale
>$$
>\begin{array}{r}
>   \ \,8 4 4 \\
>- \, 6 3 9 \\ \hline
>  2 0 5
>\end{array}
>$$

>[!NOTE] Differenza in binario
>$$
>\begin{array}{r}
>   \ \,101 \\
>+ \,110 \\ \hline
>  111
>\end{array}
>$$

---
### DECREMENT

1. Formato: `DEC destination`
2. Azione: Equivale all'istruzione `SUB $1, destination` con la sola differenza che il contenuto del flag CF non viene modificato
3. FLAG di cui viene modificato il contenuto: OF, SF e ZF

| Operandi          | Esempi      |
| ----------------- | ----------- |
| Memoria           | DECB (%EDI) |
| Registro Generale | DEC %CX     |

---
### ★ ADD WITH CARRY (ADC)

1. **Formato**

```asm6502
ADC source, destination
```
2. **Azione**: Somma il contenuto dell’operando sorgente e il flag CF (Carry Flag) all’operando destinazione.
    - Se gli operandi sono considerati naturali, CF rappresenta un riporto precedente.    
    - Se gli operandi sono considerati interi, OF segnala un traboccamento. 
3. **FLAG di cui viene modificato il contenuto**: TUTTI (CF, OF, SF, ZF, PF, AF)

|Operandi|Esempi|
|---|---|
|Memoria, Registro Generale|`ADC 0x00002000, %EDX`|
|Registro Generale, Memoria|`ADC %CL, 0x12AB1024`|
|Registro Generale, Registro Generale|`ADC %AX, %DX`|
|Immediato, Memoria|`ADCB $0x5B, (%EDI)`|
|Immediato, Registro Generale|`ADC $0x54A3, %AX`|
4. Equivale a `dest += src + CF` in C++.

---

### ★ SUBTRACT WITH BORROW (SBB)

1. **Formato**

```asm6502
SBB source, destination
```

2. **Azione**: Sottrae il contenuto dell’operando sorgente e il flag CF (Carry Flag) dall’operando destinazione.
    - CF in questo caso rappresenta un prestito precedente.
    - Se gli operandi sono considerati naturali, CF segnala un prestito;
    - Se gli operandi sono considerati interi, OF segnala un traboccamento.
3. **FLAG di cui viene modificato il contenuto**: TUTTI (CF, OF, SF, ZF, PF, AF)

|Operandi|Esempi|
|---|---|
|Memoria, Registro Generale|`SBB 0x00002000, %EDX`|
|Registro Generale, Memoria|`SBB %CL, 0x12AB1024`|
|Registro Generale, Registro Generale|`SBB %AX, %DX`|
|Immediato, Memoria|`SBBB $0x5B, (%EDI)`|
|Immediato, Registro Generale|`SBB $0x543, %AX`|
4. Equivale a `dest -= src + CF` in C++.    

---
### NEGATE (NEG)

1. **Formato**

```asm6502
NEG destination
```

2. **Azione**: Calcola il complemento a due dell’operando destinazione, equivalente a `0 - destination`.
    - Il flag CF viene impostato se l’operando non è zero (indica il prestito).
    - OF viene impostato se si verifica traboccamento nell’operazione.   
3. **FLAG di cui viene modificato il contenuto**: TUTTI (CF, OF, SF, ZF, PF, AF)

|Operandi|Esempi|
|---|---|
|Memoria|`NEGB (%EDI)`|
|Registro Generale|`NEG %CX`|
4. Equivale a `dest = -dest` in C++.

---
### COMPARE


---
## Moltiplicazione e divisione

Sono **_diverse_** per i naturali e gli interi:
-  MUL, IMUL
- DIV, IDIV
La somma di due numeri a N cifre sta su N (o N+1) cifre
- Ha senso usare un operando sia come addendo che come contenitore del risultato
Il prodotto di due numeri a N cifre sta su 2N cifre
- Fattori risultato hanno dimensioni non comparabili
- Non avrebbe senso usare un operando sia come fattore che come contenitore del risultato

---
### Moltiplicazione

Ha sia un operando che il destinatario impliciti ed esistono 3 diversi tipi di moltiplicazione:
1. 8 bit: AX = AL * source
2. 16 bit: DX AX = AX * source // parte alta su DX, parte bassa su AX
3. 32 bit: EDX_EAX = EAX * source // parte alta su EDX, parte bassa su EAX
#### 1. Multiply
#### 2. Integer Multiply

---
### ★ Divisione ★ 

Per questa valgono la maggior parte delle considerazioni fatte per la moltiplicazione, con alcuni problemi in più:
- I risultato sono due: quoziente e resto;
- L'operazione può non essere fattibile (se il divisore vale 0).
$$
\begin{aligned}
X \div Y &\rightarrow Q,R \\
0 \leq R &\leq Y -1 \rightarrow \text{(il resto sta sul n. di cifre del \textbf{divisore})} \\
0 \leq Q &\leq X \rightarrow \text{(il quoziente in teoria sta sul n. di cifre del \textbf{dividendo})}
\end{aligned}
$$
Nei processori Intex x86:
1. Esistono 3 versioni possibili
	1. 8 bit
	2. 16 bit
	3. 32 bit

|     |     |     |     |     |
| --- | --- | --- | --- | --- |
|     |     |     |     |     |
2. Il programmatore seleziona la versione opportuna, scegliendo un operando source (divisore) a 8, 16, 32 bit
3. Se il quoziente della divisione non sta sul numero di bit previsto, viene sollevata un'eccezione
	1. La stessa che partirebbe se aveste diviso per zero
	2. Il vostro programma di inchioda
4. Ci deve pensare il programmatore, selezionando la versione opportuna

>[!TIP] Esempio:
>- Voglio dividere 15000 per 3
>	- Quale versione uso?
>	|source|dimensione|dividendo|quoziente|resto|
>	|-------|-------------|-----------|-----------|------|
> 
>```asm6502
> MOV $3, %CL              MOV $3, %CX
> MOV $15000, %AX          MOV $15000, %AX
> DIV %CL                  MOV $0, %DX
>                          DIV %CX
>```

(DAFINIRE)
