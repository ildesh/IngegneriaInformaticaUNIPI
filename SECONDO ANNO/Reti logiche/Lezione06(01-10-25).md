## Ingresso / Uscita e sottoprogrammi di utilità

In Assembler non esistono istruzioni di ingresso/uscita
- Solo IN e OUT su interfacce
- Ma non e possiamo usare perché sono **istruzioni protette** e in modalità utente non si possono usare
I/O tastiera/video: si usano **servizi del Sistema** **_(DOS)_**
- Sottoprogrammi scritti da altri, che girano in modalità sistema, e possono usare le IN/OUT
- Molto primitivi: ingresso e uscita di un carattere
- Sopra questi costruiti altri servizi che consentono di fare cose di livello un po' più alto (non troppo).

>[!NOTE] Nota bene
>La codifica ASCII comunica su 7 bit e non 8 perché il bit più significativo viene considerato pari a 0.

### I/O tastiera e video

Entrano ed escono (dalla tastiera e sul video) codifiche ASCII di singoli caratteri. Non esiste I/O di variabili **tipate**.

>[!TIP] "Stampa il numero 32"
> Per stamparlo inizialmente bisogna stampare prima il carattere ASCII 0x33 ("3") e in seguito 0x32 ("2").

>[!TIP] "Per fare ingresso da tastiera di un numero naturare a 2 cifre in base 10"
> - Leggo innanzitutto e memorizzo due codifiche ASCII c<sub>1</sub>, c<sub>0</sub> 
> - Calcolo le singole cifre decimali <sub>1</sub>, a<sub>0</sub> a partire dalle codifiche c<sub>1</sub>, c<sub>0</sub> 
> - Ricostruisco il numero digitato come 
> $$ \text{10 } * a_1 + a_0 $$

---
## Ingresso/Uscita di caratteri e stringhe

- Includere il file utility con l'apposita direttiva
		`INCLUDE "C:/amb_GAS/utility`
- Alcuni sottoprogrammi di I/O:
	1. **inchar**:
		- **Cosa fa**: legge un **singolo carattere** da tastiera.
		- **Descrizione**: Questo sottoprogramma attende che l’utente prema un tasto sulla tastiera e restituisce il carattere corrispondente. Normalmente lo salva in un registro (di solito `AL` o `AX`), così che il programma possa subito utilizzarlo per calcoli, confronti o stampe.  
		- È molto utile quando si devono fare menu interattivi (scegliere un’opzione premendo una lettera o un numero), oppure quando bisogna leggere caratteri uno alla volta (per esempio per controllare se l’utente digita una lettera specifica). A differenza della lettura di una stringa, non aspetta che l’utente prema **Invio**, ma cattura immediatamente il singolo tasto.
	2. **outchar**:
		- **Cosa fa**: scrive un **singolo carattere** sullo schermo.
		- **Descrizione**: Questo sottoprogramma prende come input un carattere (di solito passato nel registro `AL`) e lo mostra a video. Non aggiunge spazi né va a capo, stampa semplicemente il simbolo richiesto.
		- È utile quando si vogliono stampare messaggi un carattere alla volta, oppure quando si vuole mostrare un simbolo in una posizione precisa dello schermo. In combinazione con `inchar`, permette di leggere un carattere e ristamparlo subito, utile per programmi di eco (input/output diretto).
	3. **newline**:
		- **Cosa fa**: manda il cursore **a capo**, come se si premesse **Invio**.
		- **Descrizione**: Questo sottoprogramma stampa i caratteri di controllo `CR` (carriage return) e `LF` (line feed), spostando il cursore all’inizio della riga successiva.
		- È molto utile per rendere l’output leggibile e ordinato, separando correttamente righe di testo. Senza questo comando, tutto il testo verrebbe scritto in sequenza sulla stessa riga.
	4. **pauseN**
		- **Cosa fa**: mette il programma **in pausa per N secondi**.
		- **Descrizione**: Riceve come parametro un numero intero `N` e sospende l’esecuzione del programma per quel tempo. Durante la pausa, il programma resta inattivo e non accetta input.
		- È utile quando si vuole lasciare il tempo all’utente per leggere un messaggio, oppure per creare effetti di temporizzazione (per esempio, una scritta che appare lentamente o una pausa prima di proseguire un calcolo).
	5. **inline**
		- **Cosa fa**: legge una **stringa di caratteri** da tastiera.
		- **Descrizione**: Questo sottoprogramma permette di digitare più caratteri consecutivi e termina la lettura quando l’utente preme **Invio**. La stringa viene memorizzata in un buffer di memoria, di solito terminata con un carattere speciale (`0` o `$`) per segnalare la fine della stringa. 
		- È molto utile per acquisire dati testuali come nomi, parole o numeri scritti in formato stringa. Rispetto a `inchar`, consente di leggere sequenze più lunghe e non un singolo tasto.
	6. **outline**
		- **Cosa fa**: stampa una **stringa intera** sullo schermo.
		- **Descrizione**: Riceve come input l’indirizzo di una stringa in memoria e la scrive a video carattere dopo carattere, fino a incontrare il terminatore di stringa (di solito `$` o `0`).
		- È utile per stampare messaggi predefiniti o stringhe generate dal programma, senza dover stampare carattere per carattere con `outchar`. In questo modo si possono visualizzare testi lunghi in maniera semplice e veloce.
	7. **outmess**
		- **Cosa fa**: stampa un **messaggio fisso** predefinito.
		- **Descrizione**: È simile a `outline`, ma pensato per messaggi standard già inclusi nel programma. Non richiede di passare un indirizzo di stringa, perché il messaggio è già incorporato.
		- È molto utile per visualizzare frasi ricorrenti come `"Errore!"`, `"Operazione completata"`, `"Inserisci un valore:"`. In questo modo si semplifica la gestione dei messaggi di servizio e si riduce il codice necessario.

---
## Ingresso/Uscita di numeri esadecimali

- **inbyte**, inword, inlong:
	- prelevano da tastiera (con eco a video) 2, 4 o 8 caratteri dalla tastiera
	- interpretano tale sequenza di caratteri come un numero esadecimale a 2, 4 o 8 cifre
	- mettono in AL, AX, EAX, il numero esadecimale digitato
	- ignorano qualunque altro carattere che viene premuto
- outbyte, outword, outlong:
	- stampano sul video, rispettivamente 2,4 o 8 caratteri, corrispondenti a cifre esadecimali, ottenute interpretando il contenuto di AL, AX, EAX come un numero naturale.

---
## Ingresso/Uscita di numeri decimali

- indecimal_byte, indecimal_word, indecimal_long:
	- prelevano da tastiera (con eco a video) <u>fino a</u> 3, 5 o 10 cifre decimali
	- interpretano tale sequenza di caratteri come un numero decimale
	- lo mettono in AL, AX, EAX.
	- Ignorano qualunque altro carattere che viene premuto
	- Se il numero decimale digitato è troppo grande viene **troncato**.
	- Si può premere invio per dare in ingresso meno di 3, 5, 10 cifre
- outdecimal_byte, outdecimal_word, outdecimal_long:
	- stampano sul video il contenuto di AL, AX, EAX, interpretato come un numero naturale sul numero di cifre strettamente necessario.

---
## Istruzioni che manipolano le stringhe

In Assembler **non esistono tipi di dati né strutture dati**
- Esistono soltanto byte, word e long
L'Assembler supporta però il concetto di **vettore**
- dichiarare vettori di variabili di una certa dimensione
- indirizzamento con **displacemente + registri base/indice**
Possiamo parte di Istruzioni stringa:
- Stringa ↔ vettore
- Servono a copiare interi buffer di memoria
- Usano i registri %ESI, %EDI come puntatori (_S: source e D: destination_)
>[!TIP] Esempio: copia di un vettore
>

### MOVE DATA FROM STRING TO STRING (_with REPEAT_)

1. Formato: `MOVSsuf REP MOVSsuf`
2. Azione: Copia il numero di byte specificato dal suffisso sufdall'indirizzo di memoria puntato da ESI all'indirizzo di memoria puntato da EDI. Se DF=O, somma ad ESI e ad EDI il numero di byte specificato dal suffisso. Se DF=I, sottrae da ESI e da EDI il numero di byte specificato dal suffisso. 
	- Se viene premesso il prefisso REP ,allora le azioni indicate sopra vengono ripetute per il numero di volte specificato in ECX, che viene decrementato fino a zero.
3. FLAG di cui viene modificato il contenuto: Nessuno

---
## Direction Flag

E' un altro bit nel registro dei flag
- STD (**set** direction flag): imposta DF a 1 (quindi viene abilitata la copia "all'indietro")
- CLD (**clear** direction flag): imposta DF a 0 (quindi viene abilitata la copia "in avanti")
Nel codice scritto prima è necessario scrivere:

```asm6502
CLD
REP MOVSL
```

Perché DF ha il valore che gli ha dato l'ultima istruzione che lo ha toccato (eseguita da chiunque e non necessariamente da noi).

---
#### Altre istruzioni stringa

- LODSsuf:
	- copia in AL, AX, oppure EAX (a seconda del suffisso) il contenuto della memoria all'indirizzo puntato da ESI
	- A seconda del valore del flag DF, incrementa o decrementa di 1,2,4 ESI.
- STOSsuf:
	- copia il registro AL, AX, oppure EAX (a seconda del suffisso) in memoria all'indirizzo puntato da EDI.
	- A seconda del valore del flag DF, incrementa o decrementa di 1,2,4 EDI.

I registri usati come puntatore implicito sono **differenti**: ESI come sorgente e EDI come destinatario.

>[!TIP] Esempi di codice che usa istruzione stringa:
> ##### Copiare un vettore da una parte ad un'altra della memoria, eseguendo la stessa operazione su tutti i suoi elementi:
>```asm6502
> 		MOV $1000, %CX
> 		LEA buffer_src, %ESI
> 		LEA buffer_src, %EDI
> 		CLD
> ciclo:  LODSL
> 	    modifica %EAX
> 		STOSL
> 		LOOP ciclo
>```

---
## Istruzioni stringa per l'I/O

- **_INSsuf_**; fa ingresso di uno, due, quattro byte dalla porta di I/O il cui offset è contenuto in DX. L'operando viene inserito in memoria a partire dall'indirizzo di memoria contenuto in EDI. A seconda del valore del flag DF, incrementa o decrementa di 1,2,4 il contenuto di EDI.
- **_OUTSsuf_**: copia uno, due, quattro byte, contenuti in memoria a partire dall'indirizzo di memoria contenuto in ESI, alla porta di I/O il cui offset è contenuto in DX. A seconda del valore del flag DF, incrementa o decrementa di 1,2,4 il contenuto di ESI.

![[IstruzioniStringaIO.png]]

- **_CMPSsuf_** (COMPARE STRING): confronta il contenuto delle locazioni (doppie locazioni, quadruple locazioni) indirizzate da ESI (sorgente) ed EDI (destinatario). A seconda del valore del flag DF, incrementa o decrementa di 1,2,4 il contenuto di ESI e di EDI.
- **_SCASsuf_** (SCAN STRING): Confronta il contenuto del registro AL, AX oppure EAX (a seconda del suffisso) con la locazione (doppie locazioni, quadruple locazioni) di memoria indirizzata da EDI. L'algoritmo usato nel confronto è identico a quello della CMP. A seconda del valore del flag DF, incrementa o decrementa di 1,2,4 il contenuto di EDI.
	- Serve a trovare un elemento di valore noto dentro a un vettore:
		- DF = 0, cerca la prima occorrenza
		- DF = 1, cerca l'ultima occorrenza

---
## Prefissi di ripetizione

- **_REP_** (): può essere usato con MOVS, STOS, INS, OUTS e viene applicato ad una istruzione (non ad un blocco di codice)

>[!CAUTION] Attenzione:
>L'utilizzo di REP con LODS è del tutto privo di senso, in quanto si finisce a sovrascrivere N volte lo stesso registro.

- **_REPE / REPNE_** (): può essere usato con CMPS, SCAS e si applica ad una istruzione e si fanno **_al massimo ECX ripetizioni_**, finché la condizione specificata è vera.
>[!ITIP] Esempio: Trovare il primo elemento differente tra due vettori
>||||||||
>|-|-|-|-|-|-|-|-|-|-|-|-|
>|array1:|.WORD|1|2|3|4|5|6|7|8|9|10|
>|array2:|.WORD|1|2|3|4|7|6|7|8|9|10|
>
>```
>CLD                     ; pulizia del flag di direzione
>LEA array1, %ESI        ; carico l'indirizzo del primo array
>LEA array2, %EDI        ; carico l'indirizzo del secondo array
>MOV $10, %ECX           ; Numero di elementi
>REPE CMPSW              ; confronta word per word finché uguali
>```
>- **Funzionamento**:
>	1. Confronta array1[0] e array2[0] → uguali → continua     
>	2. Confronta array1[1] e array2[1] → uguali → continua      
>	3. Confronta array1[2] e array2[2] → uguali → continua
>	4. Confronta array1[3] e array2[3] → uguali → continua     
>	5. Confronta array1[4]=5 e array2[4]=7 → diverso → Z=0 → si ferma
>
> - Alla fine sai **l’indice del primo elemento diverso** guardando **ECX iniziale – ECX finale**.

>[!WARNING] Perché due direzioni (DF = 0, DF = 1)?
>Ricordiamo cos'è il DF:
>>Il DF è un bit nel registro **FLAGS** e ha lo scopo di controllare se gli indici **SI/DI** si incrementano o decrementano durante le istruzioni su stringhe (`MOVS`, `CMPS`, `LODS`, `STOS`, `SCAS`).
>
>Esistono entrambe per **flessibilità**, cioè a volte si vuole elaborare array al contrario (copiare dati dalla fine all’inizio o confrontare stringhe da destra a sinistra), e per **compatibilità storica**, perché in certi algoritmi usare DF=1 evita di calcolare manualmente gli offset.




